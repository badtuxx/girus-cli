apiVersion: v1
kind: ConfigMap
metadata:
  name: docker-gerenciamento-containers-lab-es
  namespace: girus
  labels:
    app: girus-lab-template
data:
  lab.yaml: |
    name: docker-gerenciamento-containers-es
    title: "Gestión de Contenedores Docker"
    description: "Domina las técnicas de gestión del ciclo de vida de los contenedores Docker, aprendiendo a monitorear recursos, administrar logs y gestionar múltiples contenedores de forma eficiente. Este laboratorio guiado explora los comandos fundamentales para el monitoreo y administración efectiva de contenedores en entornos reales."
    duration: 30m
    image: "linuxtips/girus-devops:0.1"
    privileged: true # Acceso al Docker daemon
    tasks:
      - name: "Inspeccionando Contenedores"
        description: "Aprende a recopilar información detallada sobre contenedores en ejecución, entendiendo cómo inspeccionar metadatos, configuraciones y estado en tiempo real."
        steps:
          - "El comando `docker inspect` es una herramienta poderosa para obtener información detallada sobre los objetos Docker. Vamos a explorar cómo usar este comando para obtener insights sobre contenedores en ejecución."
          - "Primero, vamos a crear un contenedor simple para inspeccionar. Usaremos la imagen Alpine, que es una distribución Linux muy ligera, ejecutándola en background:"
          - "`docker run -d --name container-teste alpine sleep 1000`"
          - "Este comando crea un contenedor llamado 'container-teste' basado en la imagen Alpine y ejecuta el comando 'sleep 1000', que mantiene el contenedor en ejecución por 1000 segundos. La flag `-d` ejecuta el contenedor en modo detached (background)."
          - "Ahora, vamos a usar el comando `docker inspect` para obtener información detallada sobre este contenedor:"
          - "`docker inspect container-teste`"
          - "Este comando retorna un objeto JSON detallado conteniendo toda la información sobre el contenedor, incluyendo:"
          - "- ID y nombre del contenedor"
          - "- Estado actual (running, paused, exited, etc.)"
          - "- Configuraciones de red (IP, puertos, etc.)"
          - "- Volúmenes montados"
          - "- Configuraciones de ambiente"
          - "- Límites de recursos"
          - "- Metadatos del sistema de archivos"
          - "Como el JSON completo es muy extenso, podemos usar filtros para extraer información específica. Por ejemplo, para obtener solo la IP del contenedor:"
          - "`docker inspect -f '{{.NetworkSettings.IPAddress}}' container-teste`"
          - "La flag `-f` o `--format` permite usar Go templates para filtrar y formatear la salida. El template `{{.NetworkSettings.IPAddress}}` extrae solo la dirección IP del contenedor."
          - "Vamos a extraer también el estado actual del contenedor:"
          - "`docker inspect -f '{{.State.Status}}' container-teste`"
          - "Y el ID de la imagen que el contenedor está usando:"
          - "`docker inspect -f '{{.Image}}' container-teste`"
          - "Este es el ID sha256 completo de la imagen, que podemos verificar con:"
          - "`docker inspect -f '{{.Config.Image}}' container-teste`"
          - "Que retorna el nombre de la imagen como la usamos en el comando 'run'."
          - "Vamos a crear otro contenedor para fines de comparación:"
          - "`docker run -d --name container-web -p 8080:80 nginx:alpine`"
          - "Este comando crea un contenedor ejecutando Nginx con el puerto 80 del contenedor mapeado al puerto 8080 del host. Ahora podemos comparar las configuraciones de red de ambos contenedores:"
          - "`docker inspect -f 'Nombre: {{.Name}}, IP: {{.NetworkSettings.IPAddress}}, Puertos: {{.NetworkSettings.Ports}}' container-teste container-web`"
          - "Observa cómo podemos inspeccionar múltiples contenedores a la vez y cómo el contenedor Nginx tiene configuraciones de puerto diferentes."
        tips:
          - type: "tip"
            title: "Filtros Comunes para Inspect"
            content: "Algunos filtros útiles son: `{{.State.Status}}` (estado actual), `{{.NetworkSettings.IPAddress}}` (IP), `{{.Config.Cmd}}` (comando de ejecución), `{{.HostConfig.RestartPolicy}}` (política de reinicio), `{{.Mounts}}` (volúmenes montados)."
          - type: "info"
            title: "Formato JSON vs Go Templates"
            content: "Si prefieres trabajar con el JSON completo para procesamiento posterior, usa `docker inspect container-teste | jq .` (si tienes el utilitario jq instalado) o redirige a un archivo: `docker inspect container-teste > info.json`."
          - type: "warning"
            title: "Inspección de Contenedores Detenidos"
            content: "Puedes inspeccionar contenedores incluso después de que hayan sido detenidos, lo que es útil para depuración. Sin embargo, alguna información, como estadísticas de uso de recursos, no estará disponible para contenedores detenidos."
        validation:
          - command: "docker inspect container-teste -f '{{.State.Status}}' 2>/dev/null || echo 'contenedor no encontrado'"
            expectedOutput: "running"
            errorMessage: "El contenedor 'container-teste' no está en ejecución o no fue creado correctamente. Verifica el comando 'docker run'."

      - name: "Monitoreando Uso de Recursos"
        description: "Aprende a monitorear la utilización de CPU, memoria y red de los contenedores, comprendiendo cómo identificar problemas de rendimiento y optimizar recursos."
        steps:
          - "El monitoreo del uso de recursos es crucial para mantener tus contenedores funcionando de manera eficiente. Docker proporciona herramientas para visualizar el uso de CPU, memoria, red y otros recursos en tiempo real."
          - "El comando principal para monitoreo de recursos es `docker stats`. Vamos a usarlo para ver las estadísticas de nuestros contenedores en ejecución:"
          - "`docker stats --no-stream`"
          - "La flag `--no-stream` muestra un único snapshot de las estadísticas en vez de una actualización continua, que es el comportamiento por defecto. La salida incluye:"
          - "- CONTAINER ID/NAME: Identificador y nombre del contenedor"
          - "- CPU %: Porcentaje de CPU usado por el contenedor"
          - "- MEM USAGE/LIMIT: Uso de memoria actual y límite máximo"
          - "- MEM %: Porcentaje de memoria usado en relación al límite"
          - "- NET I/O: Datos de red recibidos y enviados"
          - "- BLOCK I/O: Operaciones de lectura/escritura en disco"
          - "- PIDS: Número de procesos en ejecución en el contenedor"
          - "Podemos especificar contenedores específicos para monitorear:"
          - "`docker stats --no-stream container-teste container-web`"
          - "Ahora, vamos a crear un contenedor que consume más recursos para observar el impacto en las estadísticas:"
          - "`docker run -d --name stress-test alpine sh -c 'while true; do echo \"CPU load\"; done'`"
          - "Este contenedor ejecuta un loop infinito, generando algo de carga en la CPU. Vamos a ver las estadísticas nuevamente:"
          - "`docker stats --no-stream`"
          - "Debes ver que el contenedor 'stress-test' está consumiendo más CPU que los otros."
          - "Para un monitoreo más detallado, podemos usar el comando `docker top` para ver los procesos en ejecución dentro de un contenedor específico:"
          - "`docker top container-web`"
          - "Este comando muestra una lista de los procesos en ejecución dentro del contenedor 'container-web', similar al comando 'top' de Linux, incluyendo PID, usuario, consumo de recursos y comando."
          - "Vamos a verificar los procesos en el contenedor de stress test:"
          - "`docker top stress-test`"
          - "Verás el proceso del shell y el loop 'echo' consumiendo recursos."
          - "Para casos en que necesitamos información más específica sobre un contenedor, podemos usar el comando `docker container ls` con formateo personalizado:"
          - "`docker container ls --format '{{.Names}}: {{.Status}} - {{.Ports}}' -a`"
          - "La flag `-a` incluye todos los contenedores, incluso los detenidos, y el formato personalizado muestra el nombre, estado y puertos expuestos de cada contenedor."
        tips:
          - type: "info"
            title: "Límites de Recursos"
            content: "En entornos de producción, es recomendable definir límites de recursos en los contenedores usando flags como `--memory` y `--cpus` en el comando `docker run`. Por ejemplo: `docker run --memory=512m --cpus=0.5 [imagen]` limita el contenedor a 512MB de memoria y 50% de una CPU."
          - type: "tip"
            title: "Monitoreo Continuo"
            content: "Para monitoreo continuo, ejecuta `docker stats` sin la flag `--no-stream`. Para salir del modo continuo, presiona Ctrl+C. En sistemas de producción, considera herramientas como Prometheus y Grafana para monitoreo más avanzado."
          - type: "warning"
            title: "Interpretando Estadísticas"
            content: "El uso de CPU es relativo al total de recursos del host. Por ejemplo, 100% no significa necesariamente que el contenedor está usando 100% de la CPU del host, sino 100% de lo que fue asignado al contenedor (que puede estar limitado)."
        validation:
          - command: "docker stats --no-stream stress-test 2>/dev/null | grep stress-test || echo 'contenedor no encontrado'"
            expectedOutput: "stress-test"
            errorMessage: "El contenedor 'stress-test' no está en ejecución o no fue creado correctamente. Verifica el comando 'docker run'."

      - name: "Gestionando Logs"
        description: "Accede y administra logs de contenedores para diagnóstico y solución de problemas, comprendiendo las diferentes opciones de logging de Docker."
        steps:
          - "Los logs son una parte crucial del diagnóstico y solución de problemas en contenedores. Docker captura la salida estándar (stdout) y error estándar (stderr) de cada contenedor, permitiendo acceder a esos logs fácilmente."
          - "Vamos a crear un contenedor que genera logs para demostrar las capacidades de logging de Docker:"
          - "`docker run -d --name log-generator alpine sh -c 'while true; do echo \"$(date): Log entry\"; sleep 2; done'`"
          - "Este contenedor crea una nueva entrada de log cada 2 segundos, incluyendo la fecha y hora actual."
          - "El comando básico para ver logs es `docker logs`:"
          - "`docker logs log-generator`"
          - "Este comando muestra todos los logs del contenedor 'log-generator'. Por defecto, Docker almacena todos los logs desde el inicio de la ejecución del contenedor."
          - "Para ver solo las entradas más recientes, podemos usar la flag `--tail`:"
          - "`docker logs --tail 5 log-generator`"
          - "Esto muestra solo las 5 entradas más recientes del log, lo que es útil para contenedores con muchos logs."
          - "Para seguir los logs en tiempo real (similar al comando 'tail -f'), usamos la flag `-f` o `--follow`:"
          - "`docker logs -f log-generator`"
          - "Este comando continúa mostrando nuevas entradas de log a medida que son generadas. Presiona Ctrl+C para salir del modo de seguimiento."
          - "También podemos limitar los logs por tiempo, mostrando solo entradas después de un determinado timestamp:"
          - "`docker logs --since 1m log-generator`"
          - "Este comando muestra solo los logs de los últimos 1 minuto. Podemos usar unidades como m (minutos), h (horas), etc."
          - "De la misma manera, podemos mostrar logs hasta un determinado momento:"
          - "`docker logs --until 30s log-generator`"
          - "Esto muestra logs generados hasta los últimos 30 segundos."
          - "Si queremos agregar timestamps a los logs (útil para debugging):"
          - "`docker logs --timestamps log-generator`"
          - "Esto agrega el timestamp de Docker a cada entrada de log, permitiendo correlacionar eventos."
          - "En aplicaciones reales, a menudo queremos redirigir logs para análisis o almacenamiento. Podemos hacer esto fácilmente:"
          - "`docker logs log-generator > container_logs.txt`"
          - "Este comando guarda todos los logs del contenedor en un archivo local llamado 'container_logs.txt'."
          - "Para contenedores que generan muchos logs, podemos configurar la rotación de logs. Esto se hace en el daemon de Docker, pero podemos verificar la configuración actual con:"
          - "`docker info | grep 'Logging Driver'`"
          - "El driver de logging por defecto es generalmente 'json-file', pero Docker soporta varios drivers como syslog, journald, splunk, etc., para integración con sistemas de log centralizados."
        tips:
          - type: "info"
            title: "Drivers de Logging"
            content: "Docker soporta varios drivers de logging que pueden ser configurados con la flag `--log-driver` durante la creación del contenedor. Ejemplos incluyen 'json-file' (por defecto), 'syslog', 'journald', 'fluentd', 'awslogs', 'splunk', etc."
          - type: "warning"
            title: "Rotación de Logs"
            content: "En entornos de producción, configura la rotación de logs para evitar que los logs consuman todo el espacio en disco. Esto puede hacerse por contenedor con las opciones `--log-opt max-size=10m --log-opt max-file=3`, limitando cada archivo a 10MB y manteniendo máximo 3 archivos."
          - type: "tip"
            title: "Filtrado de Logs"
            content: "Combina `docker logs` con herramientas como `grep` para filtrar entradas específicas. Por ejemplo: `docker logs log-generator | grep error` muestra solo entradas que contienen la palabra 'error'."
        validation:
          - command: "docker logs --tail 1 log-generator 2>/dev/null | grep 'Log entry' || echo 'contenedor no encontrado'"
            expectedOutput: "Log entry"
            errorMessage: "El contenedor 'log-generator' no está generando logs correctamente. Verifica el comando 'docker run'."

      - name: "Limpieza y Eliminación"
        description: "Aprende a administrar el ciclo de vida completo de los contenedores, comprendiendo cómo detener, iniciar y eliminar contenedores de forma eficiente y segura."
        steps:
          - "Después de trabajar con contenedores, es importante saber cómo administrar su ciclo de vida completo, incluyendo cómo detenerlos y eliminarlos adecuadamente para liberar recursos."
          - "**Deteniendo Contenedores**"
          - "Vamos a comenzar deteniendo algunos de los contenedores que creamos. El comando `docker stop` envía una señal SIGTERM al proceso principal del contenedor, dándole tiempo para apagarse graciosamente:"
          - "`docker stop container-teste`"
          - "Si el contenedor no se detiene después de 10 segundos (tiempo por defecto), Docker envía una señal SIGKILL forzando el cierre."
          - "Podemos detener múltiples contenedores a la vez especificando varios nombres o IDs:"
          - "`docker stop container-web stress-test`"
          - "Para verificar el estado de los contenedores, usamos:"
          - "`docker ps -a`"
          - "La flag `-a` muestra todos los contenedores, incluyendo los detenidos. Debes ver los contenedores que detuvimos con el estado 'Exited'."
          - "**Iniciando Contenedores Detenidos**"
          - "Para reiniciar un contenedor detenido, sin crear uno nuevo:"
          - "`docker start container-web`"
          - "Esto inicia el contenedor con las mismas configuraciones con que fue originalmente creado."
          - "Podemos verificar si el contenedor está corriendo:"
          - "`docker ps`"
          - "Ahora el contenedor 'container-web' debe aparecer como 'Up'."
          - "**Pausando y Despausando Contenedores**"
          - "Docker también permite pausar y despausar contenedores sin detenerlos completamente:"
          - "`docker pause container-web`"
          - "Esto suspende todos los procesos en el contenedor, pero mantiene su estado en memoria."
          - "Para verificar, podemos usar:"
          - "`docker ps`"
          - "El contenedor 'container-web' debe aparecer como 'Paused'."
          - "Para despausar:"
          - "`docker unpause container-web`"
          - "**Eliminando Contenedores**"
          - "Cuando ya no necesitamos un contenedor, podemos eliminarlo. Un contenedor debe estar detenido antes de ser eliminado:"
          - "`docker stop log-generator`"
          - "`docker rm log-generator`"
          - "Para verificar la eliminación:"
          - "`docker ps -a | grep log-generator || echo 'Contenedor eliminado con éxito'`"
          - "Si no hay salida del grep, verás 'Contenedor eliminado con éxito'."
          - "Para eliminar un contenedor tan pronto como se detenga (útil para contenedores temporales), podemos usar la flag `--rm` durante la creación:"
          - "`docker run --rm alpine echo 'Este contenedor será eliminado automáticamente después de completar'`"
          - "**Eliminación Forzada**"
          - "Para detener y eliminar un contenedor en una sola operación, podemos usar la flag `-f` (force):"
          - "`docker rm -f container-web`"
          - "Esto es equivalente a `docker stop` seguido de `docker rm`, pero debe usarse con cuidado en entornos de producción."
          - "**Eliminando Todos los Contenedores**"
          - "Para eliminar todos los contenedores detenidos:"
          - "`docker container prune -f`"
          - "La flag `-f` omite la confirmación, pero en entornos de producción, puedes querer eliminar esa flag para revisar lo que será eliminado."
