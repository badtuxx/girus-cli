apiVersion: v1
kind: ConfigMap
metadata:
  name: docker-fundamentos-lab-es
  namespace: girus
  labels:
    app: girus-lab-template
data:
  lab.yaml: |
    name: docker-fundamentos-es
    title: "Introducción a Docker"
    description: "aprende los conceptos fundamentales de containerización con Docker, desde comandos básicos hasta la ejecución y gestión de contenedores. Este laboratorio guiado explora la arquitectura de Docker, sus componentes esenciales y proporciona una base sólida para tu jornada de containerización."
    duration: 25m
    image: "linuxtips/girus-devops:0.1"
    youtubeVideo: "https://www.youtube.com/watch?v=0cDj7citEjE"
    privileged: true
    tasks:
      - name: "Explorando el Entorno Docker"
        description: "Entiende la arquitectura de Docker y sus componentes fundamentales, aprendiendo a verificar el entorno, identificar versiones y componentes básicos de la plataforma."
        steps:
          - "Docker es una plataforma de containerización que permite empaquetar aplicaciones y sus dependencias en unidades estandarizadas llamadas contenedores. A diferencia de las máquinas virtuales, los contenedores comparten el kernel del host, haciéndolos más ligeros y eficientes."
          - "La arquitectura de Docker consiste en un modelo cliente-servidor, donde el Docker CLI (Command Line Interface) se comunica con el Docker daemon (engine), responsable de la construcción, ejecución y gestión de los contenedores."
          - "vamos a comenzar verificando la versión de Docker instalada en el sistema:"
          - "`docker --version`"
          - "Este comando muestra la versión del Docker Client y Docker Engine. Es útil para confirmar que Docker está instalado correctamente e identificar la versión para fines de compatibilidad y documentación."
          - "Para obtener información más detallada sobre la instalación de Docker, incluyendo configuraciones del sistema, número de contenedores, imágenes y otros datos relevantes, ejecuta:"
          - "`docker info`"
          - "Observa las varias secciones de la salida, que incluyen detalles sobre:"
          - "• Storage Driver - Responsable de gestionar las capas de imágenes y contenedores"
          - "• Logging Driver - Cómo se capturan los logs de los contenedores"
          - "• Cgroup Driver - Sistema de gestión de recursos utilizado"
          - "• Número de contenedores e imágenes"
          - "• Configuraciones de red"
          - "Imágenes y contenedores son conceptos fundamentales de Docker:"
          - "• Las imágenes son plantillas de solo lectura que contienen instrucciones para crear contenedores"
          - "• Los contenedores son instancias ejecutables de imágenes"
          - "vamos a listar las imágenes ya disponibles localmente:"
          - "`docker images`"
          - "Si esta es una instalación nueva, tal vez no haya muchas imágenes. Las imágenes se identifican por el repositorio y tag (generalmente indicando la versión). El ID de la imagen es un identificador único."
          - "Ahora, vamos a verificar si existen contenedores en ejecución o detenidos:"
          - "`docker ps -a`"
          - "El comando `docker ps` por sí solo muestra solo contenedores en ejecución. La bandera `-a` (all) muestra todos, incluyendo los detenidos. La salida incluye:"
          - "• CONTAINER ID - Identificador único del contenedor"
          - "• IMAGE - imagen usada para crear el contenedor"
          - "• COMMAND - comando ejecutado dentro del contenedor"
          - "• STATUS - Estado actual (Up, Exited, etc.)"
          - "• PORTS - Mapeos de puerto entre host y contenedor"
          - "• NAMES - Nombre del contenedor (generado automáticamente si no se especifica)"
          - "Docker utiliza redes virtuales para permitir la comunicación entre contenedores y con el mundo externo. vamos a verificar las redes disponibles:"
          - "`docker network ls`"
          - "Por defecto, verás al menos tres redes:"
          - "• bridge - Red predeterminada para contenedores"
          - "• host - Elimina el aislamiento de red entre contenedor y host"
          - "• none - Desactiva la red para el contenedor"
        tips:
          - type: "info"
            title: "Docker CLI - Tu herramienta principal"
            content: "El comando docker es la herramienta de línea de comandos para interactuar con Docker. Siempre que tengas dudas sobre un comando, usa docker --help o docker [comando] --help."
          - type: "tip"
            title: "Formatos de salida"
            content: "Puedes cambiar el formato de salida de cualquier comando docker usando --format. Por ejemplo: docker ps --format '{{.Names}} {{.Status}}'"
          - type: "warning"
            title: "Instalaciones en entornos de producción"
            content: "En entornos de producción, aspectos como seguridad, almacenamiento y redes requieren configuración adicional. Docker Desktop (para Windows/Mac) ya viene con configuraciones predeterminadas amigables, pero instalaciones en servidores Linux generalmente necesitan ajustes adicionales."
        validation:
          - command: "docker info &>/dev/null && echo 'success' || echo 'error'"
            expectedOutput: "success"
            errorMessage: "No fue posible acceder al daemon Docker. verifica si el servicio está en ejecución."
      
      - name: "Ejecutando Contenedores"
        description: "Comprende cómo se ejecutan los contenedores, cómo interactuar con ellos y los diferentes modos de operación disponibles en Docker."
        steps:
          - "Ejecutar contenedores es la funcionalidad central de Docker. vamos a explorar diferentes formas de crear y gestionar contenedores."
          - "1. Probando el entorno con Hello World"
          - "El contenedor 'hello-world' se usa frecuentemente para verificar si Docker está funcionando correctamente. vamos a ejecutarlo:"
          - "`docker run hello-world`"
          - "Cuando ejecutamos este comando, Docker:"
          - "1. Busca la imagen 'hello-world' localmente"
          - "2. Si no la encuentra, la descarga automáticamente del Docker Hub (registry predeterminado)"
          - "3. Crea un contenedor a partir de esa imagen"
          - "4. Ejecuta el comando predeterminado definido en la imagen"
          - "5. Muestra la salida y termina el contenedor"
          - "La salida del hello-world explica exactamente lo que pasó detrás de escena, ayudando a entender el flujo básico de Docker."
          - "2. Ejecutando un servidor web (Nginx)"
          - "Ahora, vamos a ejecutar algo más práctico: un servidor web Nginx. A diferencia del hello-world, queremos que este contenedor continúe ejecutándose en segundo plano:"
          - "`docker run -d --name mi-nginx -p 8080:80 nginx`"
          - "vamos a entender cada parte de este comando:"
          - "• `docker run` - comando para crear e iniciar un contenedor"
          - "• `-d` (detached) - Ejecuta el contenedor en segundo plano"
          - "• `--name mi-nginx` - Asigna un nombre al contenedor (en lugar de un nombre aleatorio)"
          - "• `-p 8080:80` - Mapea el puerto 80 del contenedor al puerto 8080 del host"
          - "• `nginx` - Nombre de la imagen a usar"
          - "Para verificar si el contenedor está en ejecución:"
          - "`docker ps`"
          - "Debes ver 'mi-nginx' en la lista, con status 'Up'."
          - "3. Accediendo al servidor web"
          - "Como mapeamos el puerto 8080 del host al puerto 80 del contenedor, podemos acceder al Nginx:"
          - "`curl localhost:8080`"
          - "Debes ver el HTML de la página predeterminada de Nginx. En un entorno de escritorio, también podrías abrir un navegador y acceder a http://localhost:8080."
          - "4. Visualizando logs del contenedor"
          - "Es importante saber cómo verificar los logs de un contenedor para diagnóstico:"
          - "`docker logs mi-nginx`"
          - "Si accediste al Nginx, deberías ver logs de petición HTTP en las líneas más recientes."
          - "Para seguir los logs en tiempo real (similar a 'tail -f'):"
          - "`docker logs -f mi-nginx`"
          - "Presiona Ctrl+C para dejar de seguir los logs."
          - "5. Gestionando el ciclo de vida del contenedor"
          - "Los contenedores pueden ser detenidos, iniciados y reiniciados sin perder su estado:"
          - "`docker stop mi-nginx`"
          - "Esto envía una señal SIGTERM seguida de SIGKILL (después de un tiempo de espera) al proceso principal del contenedor."
          - "Para iniciar un contenedor detenido:"
          - "`docker start mi-nginx`"
          - "Y para reiniciar (equivalente a stop seguido de start):"
          - "`docker restart mi-nginx`"
          - "**6. Modo interactivo y contenedores efímeros**"
          - "Para tareas de diagnóstico o pruebas, frecuentemente queremos iniciar un contenedor temporal con acceso al shell:"
          - "`docker run -it --rm ubuntu bash`"
          - "**Explicando las banderas:**"
          - "**-it** - Combina **-i** (interactivo) y **-t** (asigna un pseudo-TTY), permitiendo interacción con el terminal"
          - "**--rm** - Elimina automáticamente el contenedor cuando termine"
          - "**ubuntu** - imagen a usar (Ubuntu Linux en este caso)"
          - "**bash** - comando a ejecutar en el contenedor (sobrescribe el CMD definido en la imagen)"
          - "Dentro del contenedor Ubuntu, ahora estás en un entorno Linux aislado. vamos a ejecutar algunos comandos para explorar:"
          - "`ls -la`"
          - "Esta es la estructura de directorios del contenedor, no de tu host."
          - "`cat /etc/os-release`"
          - "Muestra detalles de la distribución Linux dentro del contenedor."
          - "Para salir del contenedor, escribe:"
          - "`exit`"
          - "Como usamos `--rm`, el contenedor será automáticamente eliminado después de salir."
          - "7. Inspeccionando un contenedor"
          - "Para ver información detallada sobre un contenedor específico:"
          - "`docker inspect mi-nginx`"
          - "Este comando devuelve un JSON detallado con todas las configuraciones y estado del contenedor, incluyendo red, volúmenes, environment, etc."
          - "Por último, si queremos eliminar un contenedor:"
          - "`docker rm -f mi-nginx`"
          - "La bandera `-f` fuerza la eliminación incluso si el contenedor está en ejecución."
        tips:
          - type: "warning"
            title: "Puertos expuestos"
            content: "Recuerda que para acceder a servicios dentro de un contenedor desde el host, necesitas mapear los puertos con la bandera -p. ejemplo: -p [puerto-host]:[puerto-contenedor]"
          - type: "info"
            title: "Modos de ejecución"
            content: "Docker permite ejecutar contenedores en modo detached (-d), interactivo (-it) o con una combinación de banderas. Usa --rm para eliminar automáticamente el contenedor cuando termine."
          - type: "tip"
            title: "Gestión de recursos"
            content: "En entornos de producción, es recomendable limitar los recursos que cada contenedor puede usar con banderas como --memory=512m y --cpus=0.5. Esto evita que un solo contenedor comprometa la estabilidad del host."
          - type: "info"
            title: "Persistencia de datos"
            content: "Los contenedores son efímeros por naturaleza. Los datos creados dentro de un contenedor se perderán cuando sea eliminado, a menos que uses volúmenes o bind mounts para persistencia."
        validation:
          - command: "docker ps -a --format '{{.Names}}' | grep -w mi-nginx || echo ''"
            expectedOutput: "mi-nginx"
            errorMessage: "El contenedor mi-nginx no fue creado. verifica si ejecutaste el comando docker run correctamente."
          - command: "curl -s localhost:8080 | grep -q -i nginx && echo 'Nginx accesible' || echo 'Error en el acceso'"
            expectedOutput: "Nginx accesible"
            errorMessage: "No fue posible acceder al Nginx en el puerto 8080. verifica si el contenedor está ejecutándose y si el puerto está mapeado correctamente."

      - name: "Trabajando con Imágenes Docker"
        description: "aprende a buscar, descargar y gestionar imágenes Docker, entendiendo conceptos como tags, versiones y registries."
        steps:
          - "**Las imágenes Docker** son los bloques de construcción de los contenedores. Consisten en capas de solo lectura que, cuando se combinan, forman el sistema de archivos del contenedor."
          - "**1. Buscando imágenes en Docker Hub**"
          - "Docker Hub es el registry público predeterminado donde podemos encontrar miles de imágenes oficiales y de la comunidad:"
          - "`docker search ubuntu`"
          - "Este comando busca imágenes relacionadas con 'ubuntu' en Docker Hub. La salida muestra el nombre, descripción, número de estrellas (popularidad), estado oficial y si es automatizada."
          - "Para una búsqueda más específica:"
          - "`docker search --filter=stars=1000 nginx`"
          - "Esto muestra solo imágenes de Nginx con al menos 1000 estrellas."
          - "**2. Descargando imágenes (pull)**"
          - "Podemos descargar una imagen sin crear un contenedor inmediatamente:"
          - "`docker pull alpine`"
          - "Por defecto, esto descarga la tag 'latest'. Las tags se usan para versionar imágenes. Para descargar una versión específica:"
          - "`docker pull ubuntu:20.04`"
          - "Aquí, '20.04' es la tag que especifica la versión de Ubuntu que queremos."
          - "Docker usa un sistema de capas para optimizar el almacenamiento y transferencia de imágenes. Si ya tienes partes de una imagen localmente, solo se descargarán las capas nuevas."
          - "**3. Listando y gestionando imágenes locales**"
          - "Para ver todas las imágenes descargadas:"
          - "`docker images`"
          - "O con más detalles:"
          - "`docker images --digests`"
          - "El digest es un hash SHA256 que identifica únicamente el contenido de la imagen, independientemente de la tag."
          - "Para eliminar una imagen que no está siendo usada:"
          - "`docker rmi alpine`"
          - "Si la imagen está siendo usada por un contenedor (incluso detenido), necesitarás eliminar el contenedor primero o forzar la eliminación:"
          - "`docker rmi -f alpine`"
          - "**4. Entendiendo el sistema de tags**"
          - "Las tags son fundamentales para gestionar versiones de imágenes. Algunas convenciones comunes:"
          - "- `latest` - Generalmente apunta a la versión más reciente, pero esto no está garantizado"
          - "- Versiones semánticas - `3.9.6`, `2.0`, etc."
          - "- Distribuciones base - `alpine`, `slim`, `stretch`"
          - "- Combinaciones - `3.9.6-alpine`, `latest-slim`"
          - "Por ejemplo, vamos a ver las tags disponibles para Node.js:"
          - "`docker pull node:lts-alpine`"
          - "Este comando descarga la versión LTS (Long Term Support) de Node.js en una imagen Alpine Linux, que es mucho más pequeña que la imagen predeterminada."
          - "**5. Inspeccionando imágenes**"
          - "Para ver detalles de una imagen, incluyendo capas, volúmenes, puertos y otros metadatos:"
          - "`docker inspect node:lts-alpine`"
          - "Para ver el historial de capas y entender cómo se construyó la imagen:"
          - "`docker history node:lts-alpine`"
          - "Este comando muestra cada instrucción que se usó para crear la imagen, ayudando a entender su estructura interna."
        tips:
          - type: "info"
            title: "Imágenes Oficiales vs Comunidad"
            content: "Las imágenes oficiales en Docker Hub (marcadas como [OK]) son mantenidas por Docker Inc. o por socios y generalmente siguen buenas prácticas de seguridad. En entornos de producción, es recomendable usar imágenes oficiales o construir las propias."
          - type: "warning"
            title: "La Trampa de la Tag 'latest'"
            content: "Evita usar la tag 'latest' en entornos de producción, ya que puede cambiar sin aviso. Prefiere tags específicas para garantizar reproducibilidad y evitar sorpresas durante actualizaciones."
          - type: "tip"
            title: "Imágenes Base Optimizadas"
            content: "Las variantes Alpine son mucho más pequeñas que las imágenes base predeterminadas. Por ejemplo, 'node:alpine' tiene cerca de 50MB, mientras que 'node' (basada en Debian) tiene más de 300MB. Las imágenes más pequeñas son más rápidas de descargar y más seguras por tener menos paquetes instalados."
        validation:
          - command: "docker images alpine --format 'found' 2>/dev/null || echo 'not found'"
            expectedOutput: "found"
            errorMessage: "La imagen Alpine no fue descargada. Ejecuta el comando 'docker pull alpine' para descargarla."
          - command: "docker images | wc -l"
            expectedExpression: ">= 2"
            errorMessage: "Deberías tener al menos una imagen además del encabezado de la tabla. Ejecuta algunos comandos docker pull."
