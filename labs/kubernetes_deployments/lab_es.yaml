apiVersion: v1
kind: ConfigMap
metadata:
  name: kubernetes-deployments-lab-es
  namespace: girus
  labels:
    app: girus-lab-template
data:
  lab.yaml: |
    name: kubernetes-deployments-es
    title: "Kubernetes: Gestionando Aplicaciones con Deployments"
    description: "Aprende a administrar aplicaciones en Kubernetes usando Deployments, un recurso esencial para garantizar disponibilidad, escalabilidad y actualizaciones seguras de aplicaciones. Este laboratorio guiado explora el ciclo de vida completo de Deployments, incluyendo creación, actualización, rollback y escalamiento horizontal, con explicaciones detalladas de conceptos fundamentales."
    duration: 35m
    image: "linuxtips/girus-devops:0.1"
    privileged: true
    tasks:
      - name: "Conceptos Fundamentales de Deployments"
        description: "Comprende qué son los Deployments en Kubernetes, su propósito y cómo se relacionan con otros recursos del sistema."
        steps:
          - "**¿Qué son los Deployments?**"
          - "Un Deployment es un recurso de Kubernetes que proporciona actualizaciones declarativas para aplicaciones. Te permite:"
          - "- Describir el estado deseado de tu aplicación"
          - "- Cambiar el estado real al estado deseado de manera controlada"
          - "- Hacer rollback a versiones anteriores"
          - "- Pausar y reanudar actualizaciones"
          - "**Jerarquía de Recursos con Deployments**"
          - "Los Deployments crean y gestionan otros recursos en una jerarquía:"
          - "```"
          - "Deployment → ReplicaSet → Pods → Containers"
          - "```"
          - "- El **Deployment** define el estado deseado de la aplicación"
          - "- El **ReplicaSet** garantiza que el número correcto de réplicas de la aplicación esté en ejecución"
          - "- Los **Pods** son las unidades de ejecución que contienen los contenedores de la aplicación"
          - "**¿Por qué usar Deployments?**"
          - "- **Alta disponibilidad**: Mantiene múltiples réplicas de la aplicación disponibles"
          - "- **Actualizaciones sin downtime**: Implementa estrategias de actualización gradual (rolling updates)"
          - "- **Versionado**: Mantiene historial de revisiones para facilitar rollbacks"
          - "- **Escalamiento**: Permite aumentar o disminuir el número de réplicas fácilmente"
          - "- **Auto-recuperación**: Sustituye automáticamente Pods que fallan"
          - "**Estrategias de Actualización**"
          - "Kubernetes soporta dos estrategias principales de actualización vía Deployments:"
          - "1. **RollingUpdate** (por defecto): Sustituye gradualmente los pods antiguos por nuevos, garantizando disponibilidad continua"
          - "2. **Recreate**: Termina todos los pods existentes antes de crear nuevos (causa downtime)"
          - "Vamos a examinar un ejemplo de manifiesto de Deployment:"
          - "```yaml"
          - "apiVersion: apps/v1"
          - "kind: Deployment"
          - "metadata:"
          - "  name: nginx-deployment"
          - "spec:"
          - "  replicas: 3                     # Número deseado de pods"
          - "  selector:                       # Cómo el Deployment identifica los pods que gestiona"
          - "    matchLabels:"
          - "      app: nginx"
          - "  strategy:                       # Estrategia de actualización"
          - "    type: RollingUpdate"
          - "    rollingUpdate:"
          - "      maxSurge: 1                 # Cuántos pods extras pueden crearse durante la actualización"
          - "      maxUnavailable: 1           # Cuántos pods pueden quedar indisponibles durante la actualización"
          - "  template:                       # Template del Pod"
          - "    metadata:"
          - "      labels:"
          - "        app: nginx"
          - "    spec:"
          - "      containers:"
          - "      - name: nginx"
          - "        image: nginx:1.20         # Versión específica de la imagen"
          - "        ports:"
          - "        - containerPort: 80"
          - "```"
        tips:
          - type: "info"
            title: "Declarativo vs Imperativo"
            content: "Kubernetes sigue un modelo declarativo: tú declaras el estado deseado (ej: 3 réplicas), y Kubernetes trabaja para mantener ese estado, incluso después de fallos o reinicios."
          - type: "warning"
            title: "Labels y Selectors"
            content: "Los labels y selectors son cruciales para el funcionamiento de los Deployments. El selector del Deployment debe corresponder a los labels definidos en el template del Pod, de lo contrario, el Deployment no podrá administrar los Pods."
          - type: "tip"
            title: "Siempre Especifica la Versión de la Imagen"
            content: "Usa tags específicas para las imágenes (nginx:1.20) en vez de tags genéricas (nginx:latest) para garantizar previsibilidad y facilitar rollbacks."
        validation:
          - command: "kubectl api-resources | grep deployment"
            expectedExpression: "~ deployment"
            errorMessage: "No se pudo encontrar el recurso 'deployment' en el cluster. Verifica si el cluster está en ejecución."

      - name: "Creando tu Primer Deployment"
        description: "Crea un Deployment básico para una aplicación web y explora sus propiedades y comportamientos."
        steps:
          - "**Creando un Deployment vía YAML**"
          - "Vamos a crear un Deployment para una aplicación web simple usando Nginx."
          - "Crea un archivo llamado `nginx-deployment.yaml` con el siguiente contenido:"
          - "```yaml"
          - "apiVersion: apps/v1"
          - "kind: Deployment"
          - "metadata:"
          - "  name: nginx-deployment"
          - "  labels:"
          - "    app: nginx"
          - "spec:"
          - "  replicas: 3"
          - "  selector:"
          - "    matchLabels:"
          - "      app: nginx"
          - "  template:"
          - "    metadata:"
          - "      labels:"
          - "        app: nginx"
          - "    spec:"
          - "      containers:"
          - "      - name: nginx"
          - "        image: nginx:1.20"
          - "        ports:"
          - "        - containerPort: 80"
          - "```"
          - "Aplica el Deployment al cluster:"
          - "`kubectl apply -f nginx-deployment.yaml`"
          - "**Verificando el Deployment**"
          - "Vamos a verificar si el Deployment fue creado y está funcionando correctamente:"
          - "`kubectl get deployments`"
          - "La salida debe mostrar el status de tu Deployment, incluyendo el número de réplicas disponibles:"
          - "```"
          - "NAME               READY   UP-TO-DATE   AVAILABLE   AGE"
          - "nginx-deployment   3/3     3            3           30s"
          - "```"
          - "**Explorando la Jerarquía de Recursos**"
          - "Vamos a observar cómo el Deployment crea y gestiona otros recursos:"
          - "1. Verificando el ReplicaSet creado por el Deployment:"
          - "`kubectl get replicasets`"
          - "2. Verificando los Pods creados por el ReplicaSet:"
          - "`kubectl get pods -l app=nginx`"
          - "**Examinando Detalles del Deployment**"
          - "Para ver información detallada sobre el Deployment:"
          - "`kubectl describe deployment nginx-deployment`"
          - "Observa las secciones importantes como Events, que muestran el historial de acciones realizadas por el controlador del Deployment."
          - "**Accediendo a la aplicación**"
          - "Para acceder a la aplicación Nginx que acabamos de desplegar, vamos a crear un servicio temporal usando port-forward:"
          - "`POD_NAME=$(kubectl get pods -l app=nginx -o jsonpath='{.items[0].metadata.name}')`"
          - "`kubectl port-forward $POD_NAME 8080:80 &`"
          - "Ahora puedes acceder a Nginx en http://localhost:8080 o usando curl:"
          - "`curl localhost:8080`"
          - "Debes ver la página de bienvenida estándar de Nginx."
          - "Termina el port-forward cuando hayas terminado:"
          - "`pkill -f \"kubectl port-forward\"`"
        tips:
          - type: "tip"
            title: "Visualizando Eventos"
            content: "Usa 'kubectl get events --sort-by=.metadata.creationTimestamp' para ver todos los eventos recientes del cluster, lo que puede ayudar a diagnosticar problemas con Deployments."
          - type: "info"
            title: "Terminología del Status"
            content: "En la salida de 'kubectl get deployments': READY muestra pods listos/deseados, UP-TO-DATE son pods actualizados con la configuración más reciente, y AVAILABLE son pods que están atendiendo peticiones."
          - type: "warning"
            title: "Namespace"
            content: "Si no especificas un namespace, Kubernetes usará el namespace 'default'. En entornos de producción, es recomendado crear y usar namespaces específicos para diferentes aplicaciones o equipos."
        validation:
          - command: "kubectl get deployment nginx-deployment -o jsonpath='{.status.readyReplicas}'"
            expectedOutput: "3"
            errorMessage: "El Deployment no tiene 3 réplicas listas como se esperaba. Verifica los logs y eventos para identificar el problema."
          - command: "kubectl get pods -l app=nginx --no-headers | wc -l"
            expectedOutput: "3"
            errorMessage: "No se encontraron 3 pods de Nginx. Verifica si el Deployment fue creado correctamente."

      - name: "Actualizando y Gestionando Deployments"
        description: "Aprende a actualizar aplicaciones, monitorear el progreso y administrar el ciclo de vida de los Deployments."
        steps:
          - "**Actualizando la Versión de la aplicación**"
          - "Una de las funcionalidades más poderosas de los Deployments es la capacidad de actualizar aplicaciones sin downtime. Vamos a actualizar nuestro Deployment para usar una versión más reciente de Nginx:"
          - "`kubectl set image deployment/nginx-deployment nginx=nginx:1.21 --record`"
          - "El parámetro `--record` registra el comando en la historia del Deployment, lo que es útil para entender qué cambió en cada revisión."
          - "**Observando el Proceso de Actualización**"
          - "Podemos observar en tiempo real el proceso de actualización (el rolling update):"
          - "`kubectl rollout status deployment/nginx-deployment`"
          - "Este comando mostrará el progreso de la actualización, indicando cuando esté completa."
          - "**Verificando la Actualización**"
          - "Vamos a verificar si la imagen fue actualizada correctamente:"
          - "`kubectl describe deployment nginx-deployment | grep -i image`"
          - "Debes ver `Image: nginx:1.21` en la salida."
          - "Vamos también a verificar el ReplicaSet. Nota que un nuevo ReplicaSet fue creado para la nueva versión:"
          - "`kubectl get replicasets`"
          - "Debes ver dos ReplicaSets: uno con 3 réplicas (el nuevo) y otro con 0 réplicas (el antiguo)."
          - "**Historial de Revisiones**"
          - "Kubernetes mantén un historial de revisiones del Deployment, permitiendo rollbacks si es necesario:"
          - "`kubectl rollout history deployment/nginx-deployment`"
          - "Para ver detalles de una revisión específica:"
          - "`kubectl rollout history deployment/nginx-deployment --revision=2`"
          - "**Realizando un Rollback**"
          - "Si hay problemas con la nueva versión, puedes revertir fácilmente a una versión anterior:"
          - "`kubectl rollout undo deployment/nginx-deployment`"
          - "Esto revertirá a la revisión anterior (1.20). También puedes especificar una revisión específica:"
          - "`kubectl rollout undo deployment/nginx-deployment --to-revision=1`"
          - "**Escalando el Deployment**"
          - "Puedes escalar fácilmente tu Deployment para manejar más tráfico:"
          - "`kubectl scale deployment nginx-deployment --replicas=5`"
          - "Verifica si el número de réplicas fue actualizado:"
          - "`kubectl get deployment nginx-deployment`"
          - "Ahora debes ver 5 réplicas disponibles."
          - "**Pausando y Reanudando Rollouts**"
          - "Puedes pausar un Deployment para hacer múltiples actualizaciones sin desencadenar varias actualizaciones consecutivas:"
          - "`kubectl rollout pause deployment/nginx-deployment`"
          - "Haz varios cambios:"
          - "`kubectl set image deployment/nginx-deployment nginx=nginx:1.22`"
          - "`kubectl set resources deployment/nginx-deployment -c=nginx --limits=cpu=200m,memory=512Mi`"
          - "Després, reanuda el rollout para aplicar todos los cambios de una vez:"
          - "`kubectl rollout resume deployment/nginx-deployment`"
          - "Acompáñame el progreso:"
          - "`kubectl rollout status deployment/nginx-deployment`"
        tips:
          - type: "warning"
            title: "Canary Deployments"
            content: "Para lanzamientos más controlados, considera implementar una estrategia de Canary Deployment, donde inicialmente diriges solo un pequeño porcentaje del tráfico hacia la nueva versión."
          - type: "tip"
            title: "Limites de Recursos"
            content: "Siempre define límites de recursos (CPU/memoria) para tus contenedores en ambientes de producción para evitar que una aplicación consuma recursos excesivos del cluster."
          - type: "info"
            title: "Estratégias de Implantação Avançadas"
            content: "Para estrategias más allá del rolling update básico, considera herramientas como Argo Rollouts, Flagger o Spinnaker, que ofrecen recursos avanzados como Blue/Green y Canary Deployments."
        validation:
          - command: "kubectl get deployment nginx-deployment -o jsonpath='{.spec.replicas}'"
            expectedOutput: "5"
            errorMessage: "El Deployment no fue escalado para 5 réplicas como se esperaba."
          - command: "kubectl rollout history deployment/nginx-deployment | grep -c 'revision'"
            expectedExpression: ">= 2"
            errorMessage: "Não foram encontradas pelo menos 2 revisões no histórico do Deployment."

      - name: "Implementando Estratégias de actualización Avançadas"
        description: "Configura y prueba estrategias de actualización personalizadas para atender a diferentes necesidades de disponibilidad y seguridad."
        steps:
          - "**Configurando Estratégias de RollingUpdate**"
          - "Kubernetes permite configurar cómo se aplican las actualizaciones. Vamos a modificar nuestra estrategia de actualización para ser más cautelosa:"
          - "Edita el archivo `nginx-deployment.yaml` para incluir configuraciones específicas de RollingUpdate:"
          - "```yaml"
          - "apiVersion: apps/v1"
          - "kind: Deployment"
          - "metadata:"
          - "  name: nginx-deployment"
          - "  labels:"
          - "    app: nginx"
          - "spec:"
          - "  replicas: 5"
          - "  selector:"
          - "    matchLabels:"
          - "      app: nginx"
          - "  strategy:"
          - "    type: RollingUpdate"
          - "    rollingUpdate:"
          - "      maxSurge: 1        # Máximo 1 pod por encima del deseado durante la actualización"
          - "      maxUnavailable: 1  # Máximo 1 pod por debajo del deseado durante la actualización"
          - "  template:"
          - "    metadata:"
          - "      labels:"
          - "        app: nginx"
          - "    spec:"
          - "      containers:"
          - "      - name: nginx"
          - "        image: nginx:1.22"
          - "        ports:"
          - "        - containerPort: 80"
          - "        resources:"
          - "          limits:"
          - "            memory: \"512Mi\""
          - "            cpu: \"200m\""
          - "          requests:"
          - "            memory: \"256Mi\""
          - "            cpu: \"100m\""
          - "        readinessProbe:"
          - "          httpGet:"
          - "            path: /"
          - "            port: 80"
          - "          initialDelaySeconds: 5"
          - "          periodSeconds: 10"
          - "```"
          - "Observe las nuevas configuraciones:"
          - "- `strategy.type`: Define la estrategia como RollingUpdate (por defecto)"
          - "- `maxSurge`: Limita cuántos pods pueden ser creados por encima del número deseado durante la actualización"
          - "- `maxUnavailable`: Limita cuántos pods pueden estar indisponibles durante la actualización"
          - "- `readinessProbe`: Verifica si el pod está listo para recibir tráfico, crucial para actualizaciones seguras"
          - "- `resources`: Define límites y requisitos de recursos para cada contenedor"
          - "Aplique la configuración actualizada:"
          - "`kubectl apply -f nginx-deployment.yaml`"
          - "**Observando el RollingUpdate Controlado**"
          - "Acompáñame el progreso de la actualización:"
          - "`kubectl rollout status deployment/nginx-deployment`"
          - "Durante el proceso, puedes ver detalles sobre la progresión de la actualización:"
          - "`kubectl get rs -w`"
          - "(Presiona Ctrl+C para salir del modo de observación)"
          - "**Implementando la Estratégia Recreate**"
          - "Para algunas aplicaciones, puede ser necesario terminar completamente la versión antigua antes de iniciar la nueva (por ejemplo, si hay incompatibilidades entre versiones)."
          - "Vamos a modificar el Deployment para usar la estrategia Recreate:"
          - "```yaml"
          - "# Reemplaza solo la sección 'strategy' en el archivo"
          - "strategy:"
          - "  type: Recreate"
          - "```"
          - "Salve las modificaciones y aplique:"
          - "`kubectl apply -f nginx-deployment.yaml`"
          - "Observe el comportamiento diferente durante la actualización:"
          - "`kubectl rollout status deployment/nginx-deployment`"
          - "**Adicionando Sondas de Vida y Prontidão**"
          - "Las sondas (probes) son cruciales para garantizar la disponibilidad de la aplicación durante actualizaciones:"
          - "- `readinessProbe`: Determina cuándo un Pod está listo para recibir tráfico"
          - "- `livenessProbe`: Verifica si la aplicación está funcionando correctamente"
          - "- `startupProbe`: Verifica cuándo la aplicación se ha inicializado completamente"
          - "Vamos a editar el Deployment para agregar una livenessProbe:"
          - "```yaml"
          - "# Adicione al contenedor en el archivo YAML"
          - "livenessProbe:"
          - "  httpGet:"
          - "    path: /"
          - "    port: 80"
          - "  initialDelaySeconds: 15"
          - "  periodSeconds: 20"
          - "```"
          - "Aplique las modificaciones y observe el comportamiento:"
          - "`kubectl apply -f nginx-deployment.yaml`"
          - "`kubectl describe pod -l app=nginx | grep -A 10 Liveness`"
        tips:
          - type: "info"
            title: "Escolhendo a Estratégia"
            content: "Usa RollingUpdate para la mayoría de las aplicaciones que pueden coexistir en versiones diferentes. Usa Recreate solo cuando versiones diferentes no pueden coexistir (debido a incompatibilidades de DB, APIs, etc.)."
          - type: "warning"
            title: "Configuração de Probes"
            content: "Ajusta los timeouts de las sondas según las necesidades de tu aplicación. Valores muy bajos pueden causar reinicios innecesarios, mientras que valores muy altos pueden retrasar la detección de problemas."
          - type: "tip"
            title: "maxUnavailable e maxSurge"
            content: "Para actualizaciones extremadamente cautelosas, configura maxSurge=1 y maxUnavailable=0, lo que garantizará que todos los pods existentes permanezcan disponibles durante la actualización, a costa de una actualización más lenta."
        validation:
          - command: "kubectl get deployment nginx-deployment -o jsonpath='{.spec.strategy.type}'"
            expectedOutput: "Recreate"
            errorMessage: "La estrategia de Deployment no fue alterada para 'Recreate' como se esperaba."
          - command: "kubectl get pods -l app=nginx -o jsonpath='{.items[0].spec.containers[0].livenessProbe}' | grep -q httpGet && echo 'Probe configurada' || echo 'Probe não configurada'"
            expectedOutput: "Probe configurada"
            errorMessage: "La livenessProbe no fue configurada correctamente en los Pods."

      - name: "Limpeza e Boas Práticas"
        description: "Explora buenas prácticas para administrar Deployments en ambientes de producción y limpia los recursos creados en este laboratorio."
        steps:
          - "**Boas Práticas para Deployments**"
          - "Antes de concluirmos, vamos revisar algumas boas práticas essenciais para Deployments:"
          - "1. **Controle de Versão**: Sempre versione seus manifestos YAML junto com o código da aplicação"
          - "2. **Especificidade de Imagens**: Use tags específicas de imagens em vez de 'latest'"
          - "3. **Limites de Recursos**: Configure limites e requisitos de recursos adequados"
          - "4. **Sondas de Saúde**: Implemente readinessProbe y livenessProbe para cada container"
          - "5. **Service Mesh**: Para ambientes complejos, considera implementar un service mesh como Istio o Linkerd"
          - "6. **GitOps**: Considere adotar práticas de GitOps com ferramentas como ArgoCD ou Flux"
          - "7. **Monitoramento**: Implemente monitoramento robusto para seus Deployments con Prometheus e Grafana"
          - "**Deployment vs. Outros Controladores**"
          - "O Kubernetes oferece vários controladores para diferentes casos de uso:"
          - "- **Deployment**: Para aplicações stateless com atualizações graduais"
          - "- **StatefulSet**: Para aplicações stateful com identidades estáveis e armazenamento persistente"
          - "- **DaemonSet**: Para garantir que un pod específico execute em todos os nós do cluster"
          - "- **Job/CronJob**: Para tarefas de execução única ou agendadas"
          - "**Configurando Alertas e Monitoramento**"
          - "Em ambientes de produção, usted debe implementar monitoramento para seus Deployments. Alguns aspectos a monitorar:"
          - "- Disponibilidade de Pods"
          - "- Tempo de resposta da aplicação"
          - "- Uso de recursos (CPU, memória)"
          - "- Duração das atualizações"
          - "- Falhas de rollout"
          - "**Limpeza dos Recursos**"
          - "Agora vamos limpar todos os recursos que criamos neste laboratorio:"
          - "`kubectl delete deployment nginx-deployment`"
          - "verifique se todos os recursos foram removidos:"
          - "`kubectl get deployments`"
          - "`kubectl get replicasets`"
          - "`kubectl get pods -l app=nginx`"
          - "Todos esses comandos debem retornar 'No resources found'"
        tips:
          - type: "info"
            title: "Ambiente Multicluster"
            content: "Para aplicaciones críticas, considera implementar Deployments en múltiples clusters para garantizar alta disponibilidad incluso en caso de falla total de un cluster."
          - type: "tip"
            title: "Rollbacks Automatizados"
            content: "Considera implementar rollbacks automatizados basados en métricas (por ejemplo, si la tasa de error aumenta después de una actualización). Herramientas como Flagger pueden ayudar con esto."
          - type: "warning"
            title: "administración de Secrets"
            content: "Nunca armazene secrets diretamente nos manifestos de Deployment. Use el recurso Secret del Kubernetes y injecte-os como variables de entorno o volúmenes."
        validation:
          - command: "kubectl get deployment nginx-deployment 2>/dev/null || echo 'Deployment removido'"
            expectedOutput: "Deployment removido"
            errorMessage: "El Deployment no fue removido correctamente."
          - command: "kubectl get pods -l app=nginx 2>/dev/null || echo 'Pods removidos'"
            expectedOutput: "Pods removidos"
            errorMessage: "Los Pods del Deployment aún existen en el cluster."
