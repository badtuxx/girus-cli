apiVersion: v1
kind: ConfigMap
metadata:
  name: docker-fundamentos-redes-lab-es
  namespace: girus
  labels:
    app: girus-lab-template
data:
  lab.yaml: |
    name: docker-fundamentos-redes-es
    title: "Redes en Docker: Conceptos e Implementación"
    description: "Aprende los fundamentos de redes en Docker, comprendiendo los diferentes drivers de red (bridge, host, none), los mecanismos de aislamiento y comunicación entre contenedores, y cómo implementar redes personalizadas para aplicaciones multi-contenedor. Este laboratorio guiado explora conceptos prácticos esenciales para crear arquitecturas de aplicaciones containerizadas eficientes y seguras."
    duration: 35m
    image: "linuxtips/girus-devops:0.1"
    privileged: true # Necesario para administrar redes Docker
    tasks:
      - name: "Fundamentos de Redes en Docker"
        description: "Comprende la arquitectura de red de Docker, los tipos de drivers disponibles y cómo Docker gestiona la comunicación entre contenedores y con el mundo externo."
        steps:
          - "**Arquitectura de Redes en Docker**"
          - "Docker implementa un sistema de redes sofisticado que permite diferentes niveles de aislamiento y conectividad entre contenedores. Esta arquitectura está basada en **drivers de red** que proporcionan diferentes implementaciones para casos de uso específicos."
          - "**Los cuatro componentes principales de la red Docker son:**"
          - "1. **Container Network Model (CNM)**: El modelo conceptual que define la red Docker"
          - "2. **Libnetwork**: La implementación real del CNM en Docker"
          - "3. **Drivers**: Plugins que implementan diferentes tipos de red (bridge, host, overlay, etc.)"
          - "4. **IPAM Drivers**: Administración de direcciones IP (asignación de IPs, subredes, etc.)"
          - "**Principales Drivers de Red en Docker**"
          - "Docker incluye varios drivers de red por defecto, cada uno con características específicas:"
          - "- **bridge**: El driver por defecto, crea una red aislada en el host (usa interfaces virtuales e iptables)"
          - "- **host**: Elimina el aislamiento de red, el contenedor usa directamente la red del host"
          - "- **none**: Desactiva completamente la red para el contenedor"
          - "- **overlay**: Permite redes multi-host para comunicación entre contenedores en diferentes hosts"
          - "- **macvlan**: Asigna una dirección MAC al contenedor, haciéndolo aparecer como un dispositivo físico en la red"
          - "Vamos a explorar los principales drivers en este laboratorio, comenzando por los drivers por defecto."
          - "**Visualizando las Redes Disponibles**"
          - "Para listar todas las redes disponibles en Docker, usa el comando:"
          - "`docker network ls`"
          - "La salida mostrará algo como:"
          - "```"
          - "NETWORK ID     NAME      DRIVER    SCOPE"
          - "xxxxxxxxxxxx   bridge    bridge    local"
          - "xxxxxxxxxxxx   host      host      local"
          - "xxxxxxxxxxxx   none      null      local"
          - "```"
          - "Podemos ver que Docker crea tres redes por defecto: bridge (por defecto), host y none."
          - "**Obteniendo Información Detallada Sobre Redes**"
          - "Para inspeccionar una red específica y entender su configuración detallada:"
          - "`docker network inspect bridge`"
          - "Este comando mostrará un JSON con información como:"
          - "- Configuración de red (subnet, gateway)"
          - "- Driver utilizado"
          - "- Opciones de configuración"
          - "- Contenedores conectados a esta red (si los hay)"
        tips:
          - type: "info"
            title: "Docker y Namespaces"
            content: "Docker utiliza el concepto de Namespaces de Linux para aislamiento de red. Cada contenedor tiene su propio namespace de red, lo que permite que tenga sus propias interfaces, tablas de enrutamiento y reglas de firewall."
          - type: "tip"
            title: "Inspeccionando Recursos Docker"
            content: "El comando 'docker inspect' es extremadamente útil para debug. Puedes usar formateadores para extraer información específica, como: 'docker network inspect -f \"{{.IPAM.Config}}\" bridge'"
          - type: "warning"
            title: "Modificando Redes Por Defecto"
            content: "Evita modificar las configuraciones de las redes por defecto de Docker. Es mejor crear nuevas redes personalizadas para tus necesidades específicas."
        validation:
          - command: "docker network ls | grep -q bridge && echo 'ok'"
            expectedOutput: "ok"
            errorMessage: "La red 'bridge' por defecto no fue encontrada. Verifica la instalación de Docker."
          - command: "docker network ls | wc -l"
            expectedExpression: "> 3"
            errorMessage: "Docker debe crear al menos 3 redes por defecto."

      - name: "Red Bridge Por Defecto"
        description: "Explora el funcionamiento de la red bridge por defecto de Docker, comprendiendo sus características, limitaciones y casos de uso."
        steps:
          - "**Red Bridge Por Defecto: Concepto y Funcionamiento**"
          - "La red 'bridge' es el driver por defecto usado por Docker cuando no especificas una red. Crea una red privada interna en el host donde los contenedores pueden comunicarse entre sí, mientras mantiene aislamiento del resto del mundo."
          - "Técnicamente, Docker crea una interfaz de bridge virtual llamada 'docker0' en el host, a la cual los contenedores se conectan a través de interfaces virtuales pareadas (veth pairs)."
          - "Vamos a explorar esta red en detalle:"
          - "`docker network inspect bridge`"
          - "Observa en la salida la subnet utilizada (generalmente 172.17.0.0/16) y el gateway (generalmente 172.17.0.1), que corresponde a la interfaz docker0 en el host."
          - "**Ejecutando Contenedores en la Red Bridge**"
          - "Cuando ejecutas un contenedor sin especificar una red, se conecta a la red bridge por defecto y recibe una IP de esta subnet:"
          - "`docker run --rm alpine ip addr show eth0`"
          - "Verás que el contenedor recibe una dirección IP de la subnet del bridge (generalmente algo como 172.17.0.x)."
          - "**Probando Conectividad en la Red Bridge**"
          - "Vamos a ejecutar dos contenedores Nginx en background para probar la conectividad entre ellos:"
          - "`docker run -d --name web1 nginx:alpine`"
          - "`docker run -d --name web2 nginx:alpine`"
          - "Ahora, vamos a intentar hacer ping a 'web2' desde 'web1' usando el nombre:"
          - "`docker exec web1 ping -c 2 web2 || echo 'Ping falló o nombre no resuelto'`"
          - "**Este comando probablemente fallará.** Esto ocurre porque la red bridge por defecto **no ofrece resolución de nombres automática** entre contenedores. Cada contenedor puede ver apenas su propio nombre de host."
          - "Sin embargo, la comunicación por IP funciona perfectamente. Vamos a obtener la IP de 'web2' e intentar nuevamente:"
          - "`IP_WEB2=$(docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' web2)`"
          - "`echo \"La IP del contenedor web2 es: $IP_WEB2\"`"
          - "`docker exec web1 ping -c 2 $IP_WEB2`"
          - "Esta comunicación debe ser exitosa, demostrando que los contenedores en la red bridge por defecto pueden comunicarse vía IP, pero no por nombre."
          - "**Publicando Puertos en la Red Bridge**"
          - "Para que servicios dentro de los contenedores sean accesibles desde el host o desde afuera, es necesario publicar puertos usando el parámetro `-p` o `--publish`:"
          - "`docker stop web1`"
          - "`docker run -d --name web1 -p 8080:80 nginx:alpine`"
          - "Este comando mapea el puerto 8080 del host al puerto 80 del contenedor. Ahora, puedes acceder al Nginx del contenedor a través del host:"
          - "`curl localhost:8080`"
          - "Internamente, Docker configura reglas de NAT (DNAT) en iptables para redirigir el tráfico del puerto 8080 del host al puerto 80 del contenedor."
          - "**Limpieza**"
          - "Vamos a remover los contenedores antes de continuar:"
          - "`docker stop web1 web2 && docker rm web1 web2`"
        tips:
          - type: "info"
            title: "Red Bridge Por Defecto"
            content: "La red 'bridge' por defecto aísla los contenedores del mundo externo, pero permite comunicación entre ellos por IP. La resolución de nombres entre contenedores no está habilitada por defecto en esta red, siendo esta una de sus principales limitaciones."
          - type: "warning"
            title: "Limitaciones de Seguridad"
            content: "Todos los contenedores en el bridge por defecto comparten la misma red, pudiendo haber falta de aislamiento adecuado para aplicaciones críticas. Para mejor aislamiento, considera usar redes bridge personalizadas."
          - type: "tip"
            title: "Publicación de Puertos"
            content: "Al publicar puertos con '-p', puedes especificar interfaces específicas, como '-p 127.0.0.1:8080:80' para permitir acceso apenas desde localhost, aumentando la seguridad."
        validation:
          - command: "docker network inspect bridge -f '{{.Driver}}'"
            expectedOutput: "bridge"
            errorMessage: "La red por defecto 'bridge' no fue encontrada o no es del tipo bridge."
          - command: "ip addr show docker0 2>/dev/null | grep -q 'inet' && echo 'ok' || echo 'Sin interfaz docker0'"
            expectedOutput: "ok"
            errorMessage: "La interfaz docker0 no fue encontrada en el host. Verifica la configuración de Docker."

      - name: "Red Host"
        description: "Explora el driver de red 'host', entendiendo sus implicaciones de rendimiento y seguridad, y cuándo es apropiado utilizarlo."
        steps:
          - "**El Driver de Red 'host': Eliminando el Aislamiento**"
          - "El driver de red 'host' elimina completamente el aislamiento de red entre el contenedor y el host. En lugar de crear un namespace de red separado, el contenedor usa directamente el namespace de red del host."
          - "Esto significa que el contenedor:"
          - "- Comparte la pila de red, interfaces y direcciones IP con el host"
          - "- Tiene acceso directo a todos los servicios de red del host"
          - "- No requiere mapeo de puertos (publicación de puertos es ignorada e innecesaria)"
          - "**¿Cuándo usar la red 'host'?**"
          - "La red host es útil principalmente en dos escenarios:"
          - "1. **Rendimiento**: Elimina la sobrecarga del NAT y de los bridges virtuales, ofreciendo rendimiento de red nativo"
          - "2. **Acceso a interfaces específicas**: Cuando el contenedor necesita acceder directamente a interfaces de red específicas del host"
          - "**Probando la Red Host**"
          - "Vamos a visualizar el efecto de la red host ejecutando un contenedor Alpine y comparando sus interfaces de red con las del host:"
          - "`docker run --rm --network host alpine ifconfig`"
          - "Compara la salida anterior con las interfaces de red del propio host:"
          - "`ifconfig`"
          - "Observa que las salidas son idénticas o muy similares, indicando que el contenedor está usando directamente las interfaces de red del host."
          - "**Demostración Práctica: Servidor Web en la Red Host**"
          - "Vamos a ejecutar un servidor Nginx en la red host:"
          - "`docker run -d --name nginx-host --network host nginx:alpine`"
          - "Nota que no necesitamos especificar el mapeo de puertos con `-p`. El Nginx estará disponible directamente en el puerto 80 del host (siempre que nada más esté usando este puerto):"
          - "`curl localhost:80`"
          - "Si el comando anterior retorna la página HTML del Nginx, significa que el servidor está accesible directamente a través de la red del host."
          - "**Conflictos de Puerto en la Red Host**"
          - "Un aspecto importante a considerar con la red host es el potencial para conflictos de puerto. Vamos a demostrar esto intentando ejecutar dos servidores Nginx en la red host:"
          - "`docker run -d --name nginx-host2 --network host nginx:alpine`"
          - "Este comando probablemente fallará o causará problemas, pues el segundo contenedor intentará utilizar el mismo puerto 80 que ya está en uso por el primer contenedor."
          - "**Limpieza**"
          - "`docker stop nginx-host nginx-host2 2>/dev/null || true`"
          - "`docker rm nginx-host nginx-host2 2>/dev/null || true`"
        tips:
          - type: "warning"
            title: "Riesgos de la Red Host"
            content: "Usar `--network host` elimina el aislamiento de red, lo que representa un riesgo significativo de seguridad. El contenedor puede acceder a cualquier servicio ejecutándose en el host y puede haber conflictos de puerto. Usa con precaución, especialmente en ambientes de producción."
          - type: "info"
            title: "Rendimiento vs Seguridad"
            content: "La red host ofrece mejor rendimiento al eliminar la capa de virtualización de red, pero al costo de seguridad y aislamiento. Evalúa este trade-off basándote en los requisitos de tu aplicación."
          - type: "tip"
            title: "Monitoreo de Red"
            content: "Contenedores que necesitan monitorear el tráfico de red del host (como herramientas de IDS/IPS) generalmente se benefician de la red host, pues pueden ver todo el tráfico pasando por las interfaces físicas."
        validation:
          - command: "docker run --rm --network host alpine hostname"
            expectedOutput: "`hostname`" # Captura el hostname real del host donde el lab corre
            errorMessage: "El contenedor ejecutado con --network host no parece estar compartiendo el hostname del host."
          - command: "docker run --rm --network host alpine ip addr | grep -q docker0 && echo 'Interfaces del host visibles' || echo 'Interfaces del host no visibles'"
            expectedOutput: "Interfaces del host visibles"
            errorMessage: "El contenedor con red host no parece estar visualizando las interfaces del host correctamente."

      - name: "Red Bridge Personalizada"
        description: "Aprende a crear y utilizar redes bridge personalizadas para obtener mejor aislamiento, resolución de nombres automática y control más granular sobre la comunicación entre contenedores."
        steps:
          - "**Redes Personalizadas: Superando las Limitaciones del Bridge Por Defecto**"
          - "Las redes bridge personalizadas resuelven varias limitaciones de la red bridge por defecto, ofreciendo:"
          - "- **Resolución de nombres automática**: Contenedores pueden comunicarse usando nombres, no apenas IPs"
          - "- **Mejor aislamiento**: Contenedores en redes diferentes no pueden comunicarse directamente"
          - "- **Configuración más flexible**: Opciones para configurar IPAM, MTU, etc."
          - "- **Mejor seguridad**: Aislamiento más preciso entre grupos de contenedores"
          - "**Creando una Red Bridge Personalizada**"
          - "Para crear una nueva red bridge, usamos el comando `docker network create`:"
          - "`docker network create mi-red`"
          - "El comando anterior crea una red bridge básica con configuraciones por defecto. Para configuraciones más avanzadas, podemos especificar parámetros adicionales:"
          - "`docker network create --driver bridge --subnet=192.168.10.0/24 --gateway=192.168.10.1 mi-red-personalizada`"
          - "**Inspeccionando la Nueva Red**"
          - "Vamos a examinar la red que acabamos de crear:"
          - "`docker network inspect mi-red`"
          - "Observa en la salida el driver utilizado (bridge), la subnet asignada y otras configuraciones. En este momento, no hay contenedores conectados a la red."
          - "**Conectando Contenedores a la Red Personalizada**"
          - "Vamos a ejecutar dos contenedores Nginx y conectarlos a nuestra red personalizada:"
          - "`docker run -d --name web-net1 --network mi-red nginx:alpine`"
          - "`docker run -d --name web-net2 --network mi-red nginx:alpine`"
          - "**Probando la Resolución de Nombres**"
          - "Ahora, vamos a probar la resolución de nombres entre los contenedores en la red personalizada:"
          - "`docker exec web-net1 ping -c 2 web-net2`"
          - "Observa que, diferentemente de la red bridge por defecto, la comunicación por nombre funciona automáticamente! Esto ocurre porque Docker implementa un servidor DNS incorporado para las redes personalizadas."
          - "**Verificando el Aislamiento de Red**"
          - "Una característica importante de las redes personalizadas es el aislamiento. Contenedores en diferentes redes no pueden comunicarse directamente. Vamos a demostrar esto:"
          - "`docker run -d --name web-default nginx:alpine` # Este contenedor usa la red bridge por defecto"
          - "Ahora, vamos a intentar comunicación entre un contenedor en la red personalizada y otro en la red por defecto:"
          - "`docker exec web-net1 ping -c 2 web-default || echo 'Comunicación bloqueada - redes aisladas'`"
          - "El comando debe fallar, demostrando que las redes están aisladas entre sí."
          - "**Limpieza**"
          - "`docker stop web-net1 web-net2 web-default && docker rm web-net1 web-net2 web-default`"
          - "`docker network rm mi-red mi-red-personalizada`"
        tips:
          - type: "info"
            title: "DNS Automático en Redes Personalizadas"
            content: "Docker proporciona resolución DNS automática apenas para redes bridge personalizadas. Esto permite que los contenedores se comuniquen usando nombres de contenedor como hostnames."
          - type: "tip"
            title: "Conectando y Desconectando Contenedores"
            content: "Puedes conectar un contenedor en ejecución a una red adicional usando 'docker network connect mi-red contenedor' y desconectar con 'docker network disconnect'."
          - type: "warning"
            title: "Limitaciones de Subnet"
            content: "Al crear redes personalizadas con subnets específicas, asegúrate de que no entren en conflicto con otras redes en tu sistema o infraestructura."
        validation:
          - command: "docker network create test-validation && docker network rm test-validation && echo 'ok'"
            expectedOutput: "ok"
            errorMessage: "No fue posible crear y remover una red de prueba. Verifica los permisos de Docker."

      - name: "Análisis Avanzado de Redes Docker"
        description: "Aprende a inspeccionar y diagnosticar redes Docker en el nivel del sistema operativo, comprendiendo la implementación subyacente de bridges, interfaces y reglas de enrutamiento."
        steps:
          - "**Vista Interna de la Implementación de Redes Docker**"
          - "Para entender completamente cómo Docker implementa sus redes, vamos a examinar las interfaces y configuraciones creadas en el nivel del sistema operativo."
          - "**Examinando Bridges Virtuales**"
          - "Cada red bridge del Docker crea una bridge virtual Linux. Vamos a ver todas las bridges en el sistema:"
          - "`ip link show type bridge`"
          - "usted debe ver la bridge por defecto 'docker0' y posiblemente otras bridges para las redes personalizadas que creamos."
          - "Para ver las configuraciones de IP de estas bridges:"
          - "`ip addr show type bridge`"
          - "**Interfaces de Contenedor (veth pairs)**"
          - "Docker conecta contenedores a las bridges usando pares de interfaces virtuales Ethernet (veth pairs). un lado del par está dentro del namespace de red del contenedor (generalmente eth0), y el otro está conectado a la bridge en el namespace del host."
          - "Para ver todas las interfaces veth en el host:"
          - "`ip link show type veth`"
          - "**Relacionamiento contenedor-veth**"
          - "Vamos a crear un contenedor y examinar su interfaz de red:"
          - "`docker run -d --name container-teste nginx:alpine`"
          - "`docker exec container-teste ip link show eth0`"
          - "Ahora vamos a encontrar el par correspondiente en el host. Primero, necesitamos el ID del namespace de red del contenedor:"
          - "`NETNS=$(docker inspect -f '{{.NetworkSettings.SandboxKey}}' container-teste)`"
          - "`echo \"Namespace de red: $NETNS\"`"
          - "Podemos ver todas las interfaces veth y su namespace de destino (peer):"
          - "`ip link show type veth | grep -A1 veth`"
          - "**Reglas de NAT (iptables)**"
          - "Docker configura reglas de NAT para permitir que contenedores en la red bridge accedan a la red externa y para implementar la publicación de puertos:"
          - "`sudo iptables -t nat -L -n | grep -E 'MASQUERADE|DNAT'`"
          - "**Limpieza**"
          - "`docker stop container-teste && docker rm container-teste`"
        tips:
          - type: "info"
            title: "Herramientas de Diagnóstico"
            content: "Para problemas complejos de red Docker, herramientas como tcpdump, nsenter y netshoot (contenedor de diagnóstico de red) pueden ser extremadamente útiles para analizar el tráfico y la configuración de red."
          - type: "warning"
            title: "Modificando Interfaces Manualmente"
            content: "Ten extremo cuidado al modificar manualmente interfaces o reglas relacionadas con Docker. El daemon de Docker puede sobrescribir sus cambios o se compuertor de manera inesperada."
          - type: "tip"
            title: "Persistencia de Configuración"
            content: "Para hacer que las configuraciones de red Docker persistentes, defínalas en el archivo daemon.json en lugar de crear manualmente redes después de cada reinicialización del Docker."
        validation:
          - command: "ip link show docker0 2>/dev/null | grep -q 'UP' && echo 'docker0 activa' || echo 'docker0 inativa o no encontrada'"
            expectedOutput: "docker0 activa"
            errorMessage: "La interfaz bridge docker0 no está activa o no fue encontrada."
          - command: "ip addr show type bridge 2>/dev/null | grep -q 'inet' && echo 'Bridge con IP configurado' || echo 'Bridge sin IP'"
            expectedOutput: "Bridge con IP configurado"
            errorMessage: "Las bridges Docker no parecen tener direcciones IP configuradas."
