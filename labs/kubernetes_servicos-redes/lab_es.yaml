apiVersion: v1
kind: ConfigMap
metadata:
  name: kubernetes-servicos-redes-lab-es
  namespace: girus
  labels:
    app: girus-lab-template
data:
  lab.yaml: |
    name: kubernetes-servicos-redes-es
    title: "Servicios y Redes en Kubernetes"
    description: "Aprende cómo exponer aplicaciones ejecutándose en Pods e implementar la comunicación entre los componentes de tu aplicación usando los tipos de servicios de Kubernetes. Este laboratorio guiado explorará los conceptos fundamentales de redes en Kubernetes y cómo posibilitan la comunicación interna y externa a tus aplicaciones."
    duration: 30m
    image: "linuxtips/girus-kind-single-node:0.1"
    tasks:
      - name: "Creando un Namespace Aislado"
        description: "Configura un namespace para aislar los recursos creados durante este laboratorio, comprendiendo cómo los namespaces proporcionan aislamiento lógico en Kubernetes."
        steps:
          - "En Kubernetes, **namespaces** proporcionan una forma de segmentar un cluster en ambientes virtuales aislados. Son fundamentales para organizar recursos en equipos grandes, separar ambientes (dev, test, producción) o aislar proyectos."
          - "Vamos a crear un namespace dedicado para este laboratorio usando el comando `kubectl create namespace`:"
          - "`kubectl create namespace servicios-lab`"
          - "Este comando instruye a la API de Kubernetes a crear un nuevo namespace llamado 'servicios-lab'. El namespace actúa como un scope virtual dentro del cluster, donde los recursos se nombran de forma única."
          - "Vamos a verificar si el namespace fue creado correctamente listando todos los namespaces disponibles:"
          - "`kubectl get namespaces`"
          - "Debes ver el namespace 'servicios-lab' en la lista, junto con los namespaces por defecto como 'default', 'kube-system' y otros."
          - "Para facilitar nuestros comandos, vamos a configurar el namespace 'servicios-lab' como el namespace por defecto para nuestra sesión actual:"
          - "`kubectl config set-context --current --namespace=servicios-lab`"
          - "Este comando altera el contexto actual de kubectl para usar 'servicios-lab' como namespace por defecto. Esto significa que no necesitaremos especificar `-n servicios-lab` en cada comando que ejecutemos."
        tips:
          - type: "info"
            title: "Namespaces en Kubernetes"
            content: "Los namespaces proporcionan aislamiento lógico, no físico. Recursos como nodes y PersistentVolumes no son aislados por namespace. Algunos recursos, como Nodes, son globales y no pertenecen a ningún namespace."
          - type: "tip"
            title: "Visualizar el Namespace Actual"
            content: "El comando `kubectl config view --minify | grep namespace:` muestra el namespace actual configurado en tu contexto. Si no hay namespace configurado, el comando no mostrará nada y se usará 'default'."
        validation:
          - command: "kubectl get ns servicios-lab -o jsonpath='{.metadata.name}' 2>/dev/null || echo 'Namespace no encontrado'"
            expectedOutput: "servicios-lab"
            errorMessage: "El namespace 'servicios-lab' no fue creado correctamente. Verifica el comando usado para crear el namespace."

      - name: "Creando una Aplicación con Múltiples Pods"
        description: "Despliega una aplicación web simple con frontend y backend para demostrar cómo los servicios de Kubernetes facilitan la comunicación entre componentes de la aplicación."
        steps:
          - "Antes de discutir servicios, necesitamos crear algunos Pods para exponer. En aplicaciones reales, generalmente tenemos varios componentes que necesitan comunicarse entre sí, como frontend y backend."
          - "**Deployments** son recursos de Kubernetes que gestionan la creación y actualización de Pods de forma declarativa. Vamos a crear un Deployment para el backend de nuestra aplicación:"
          - "`kubectl create deployment backend-app --image=nginxdemos/hello:0.3 --port=80 --replicas=2 -n servicios-lab`"
          - "Este comando crea un Deployment llamado 'backend-app' con 2 réplicas (2 Pods idénticos) usando la imagen 'nginxdemos/hello:0.3', que es una imagen Nginx con una página personalizada. La flag `--port=80` indica que el contenedor expone el puerto 80."
          - "Vamos a verificar si el Deployment fue creado y sus Pods están en ejecución:"
          - "`kubectl get deployments -n servicios-lab`"
          - "Debes ver el Deployment 'backend-app' con 2 réplicas disponibles."
          - "Ahora vamos a ver los Pods creados por el Deployment:"
          - "`kubectl get pods -n servicios-lab`"
          - "Debes ver 2 Pods con nombres que empiecen con 'backend-app-', cada uno en estado 'Running'."
          - "Ahora, vamos a crear otro Deployment para representar el frontend de nuestra aplicación:"
          - "`kubectl create deployment frontend-app --image=nginx:alpine --port=80 -n servicios-lab`"
          - "Este comando crea un Deployment para el frontend usando la imagen 'nginx:alpine', que es una versión liviana de Nginx. Por defecto, Kubernetes creará apenas 1 réplica cuando no especificamos el número de réplicas."
          - "Vamos a verificar todos los Deployments en el namespace:"
          - "`kubectl get deployments -n servicios-lab`"
          - "Ahora debes ver dos Deployments: 'backend-app' con 2 réplicas y 'frontend-app' con 1 réplica."
          - "Para demostrar cómo los Pods reciben IPs internos en Kubernetes, vamos a listar los Pods con sus IPs:"
          - "`kubectl get pods -o wide -n servicios-lab`"
          - "La flag `-o wide` muestra información adicional, incluyendo los IPs de los Pods. Observa que cada Pod recibe una IP única dentro de la red del cluster. Estas IPs son efímeras - cuando un Pod es recreado, recibe una nueva IP."
        tips:
          - type: "info"
            title: "Red de Pods en Kubernetes"
            content: "Kubernetes asigna a cada Pod una IP única dentro del cluster. Todos los contenedores dentro de un Pod comparten la misma IP y espacio de puertos. La comunicación entre Pods es posible por defecto, pero la IP del Pod cambiará si es recreado."
          - type: "warning"
            title: "Comunicación Directa entre Pods"
            content: "Aunque es posible comunicarse directamente con un Pod usando su IP, este enfoque es desaconsejado porque las IPs de los Pods son efímeras. En su lugar, usa servicios para descubrimiento y comunicación estable."
          - type: "tip"
            title: "Escalando Deployments"
            content: "Puedes alterar el número de réplicas de un Deployment con `kubectl scale deployment <nombre> --replicas=<número>`. Kubernetes creará o removerá Pods para alcanzar el número deseado."
        validation:
          - command: "kubectl get pods -n servicios-lab -l app=backend-app --no-headers | wc -l"
            expectedOutput: "2"
            errorMessage: "No fueron encontrados 2 Pods para el backend-app. Verifica si el Deployment fue creado correctamente con 2 réplicas."
          - command: "kubectl get pods -n servicios-lab -l app=frontend-app --no-headers | wc -l"
            expectedOutput: "1"
            errorMessage: "No fue encontrado 1 Pod para el frontend-app. Verifica si el Deployment fue creado correctamente."

      - name: "Creando un Servicio ClusterIP"
        description: "Crea un servicio del tipo ClusterIP para exponer el backend internamente en el cluster, entendiendo cómo los servicios proporcionan descubrimiento de servicio estable y balanceamiento de carga."
        steps:
          - "Ahora que tenemos nuestros Pods en ejecución, necesitamos una forma de accederlos de manera confiable. Como se mencionó, las IPs de los Pods son efímeras y no deben ser usadas directamente."
          - "Los **servicios** en Kubernetes proporcionan una abstracción que define un conjunto lógico de Pods y una política para accederlos. Permiten el descubrimiento de servicio y el balanceamiento de carga entre Pods."
          - "El tipo más básico de servicio es el **ClusterIP**, que expone el servicio en una IP interna al cluster. Este tipo es ideal para comunicación interna entre componentes de la aplicación."
          - "Vamos a crear un servicio ClusterIP para el backend:"
          - "`kubectl expose deployment backend-app --name=backend-service --port=80 --target-port=80 --type=ClusterIP -n servicios-lab`"
          - "Este comando crea un servicio llamado 'backend-service' que expone el Deployment 'backend-app' en el puerto 80. Vamos a entender cada parámetro:"
          - "- `--name=backend-service`: Define el nombre del servicio"
          - "- `--port=80`: El puerto en que el servicio será expuesto dentro del cluster"
          - "- `--target-port=80`: El puerto del Pod objetivo al cual el tráfico será redirigido"
          - "- `--type=ClusterIP`: El tipo de servicio (ClusterIP es el por defecto, por eso es opcional)"
          - "Vamos a verificar el servicio creado:"
          - "`kubectl get services -n servicios-lab`"
          - "Verás el servicio 'backend-service' con una IP interna (ClusterIP) asignada. Esta IP es estática durante el ciclo de vida del servicio."
          - "Podemos obtener más detalles sobre el servicio con el comando 'describe':"
          - "`kubectl describe service backend-service -n servicios-lab`"
          - "Observa que el servicio tiene un conjunto de 'Endpoints' que son las IPs de los Pods individuales de backend. Kubernetes mantiene esta lista actualizada automáticamente a medida que Pods son creados o removidos."
          - "Ahora, vamos a probar el acceso al backend desde otro Pod. Vamos a usar el Pod del frontend para enviar una petición HTTP al backend:"
          - "`kubectl exec -it $(kubectl get pod -l app=frontend-app -o jsonpath='{.items[0].metadata.name}' -n servicios-lab) -n servicios-lab -- curl -s backend-service`"
          - "Este comando ejecuta 'curl' dentro del Pod frontend para acceder al 'backend-service'. Observa que usamos el nombre del servicio como hostname, no su IP. Kubernetes configura DNS interno automáticamente para resolver nombres de servicios."
          - "El resultado mostrará la página HTML retornada por el backend. Kubernetes balanceó la petición hacia uno de los Pods del backend."
        tips:
          - type: "info"
            title: "Tipos de servicios"
            content: "Kubernetes ofrece varios tipos de servicios: ClusterIP (por defecto, solo interno), NodePort (expone en puerto del Node), LoadBalancer (usa balanceador de carga externo) y ExternalName (redirección DNS)."
          - type: "tip"
            title: "DNS de Kubernetes"
            content: "Kubernetes configura automáticamente nombres DNS para servicios. Dentro del mismo namespace, Pods pueden acceder a un servicio simplemente por el nombre. Entre namespaces, usa 'nombre-servicio.namespace.svc.cluster.local'."
          - type: "info"
            title: "Selectores y Endpoints"
            content: "Los servicios usan selectores de labels para identificar cuáles Pods deben recibir tráfico. Los Endpoints son una lista de todas las IPs y puertos de los Pods que corresponden al selector del servicio."
        validation:
          - command: "kubectl get service backend-service -n servicios-lab -o jsonpath='{.spec.type}' 2>/dev/null || echo ''"
            expectedOutput: "ClusterIP"
            errorMessage: "El servicio 'backend-service' del tipo ClusterIP no fue creado correctamente."
          - command: "kubectl get endpoints backend-service -n servicios-lab -o jsonpath='{.subsets[0].addresses}' 2>/dev/null | grep -c 'ip'"
            expectedOutput: "2"
            errorMessage: "El servicio 'backend-service' no está asociado a 2 Pods backend. Verifica si el selector del servicio corresponde a las labels de los Pods."

      - name: "Creando un Servicio NodePort"
        description: "Expón el frontend para acceso externo usando un servicio NodePort, entendiendo cómo este tipo de servicio permite el acceso a aplicaciones desde fuera del cluster."
        steps:
          - "Hasta ahora, nuestro 'backend-service' solo puede ser accedido desde dentro del cluster. Para exponer servicios para acceso externo, Kubernetes ofrece otros tipos de servicios."
          - "El **NodePort** es un tipo de servicio que expone el servicio en un puerto estático en cada nodo del cluster. Este puerto es accesible externamente a través de la IP del nodo."
          - "Vamos a crear un servicio NodePort para el frontend:"
          - "`kubectl expose deployment frontend-app --name=frontend-service --port=80 --target-port=80 --type=NodePort -n servicios-lab`"
          - "Este comando crea un servicio llamado 'frontend-service' del tipo NodePort que expone el Deployment 'frontend-app'. Kubernetes asignará automáticamente un puerto aleatorio en el rango 30000-32767."
          - "Vamos a verificar el servicio creado:"
          - "`kubectl get services -n servicios-lab`"
          - "Verás el servicio 'frontend-service' con un ClusterIP asignado y un campo 'PORT(S)' mostrando algo como '80:3xxxx/TCP', donde 3xxxx es el puerto NodePort asignado."
          - "Vamos a capturar ese puerto NodePort para uso posterior:"
          - "`NODEPORT=$(kubectl get service frontend-service -n servicios-lab -o jsonpath='{.spec.ports[0].nodePort}')`"
          - "Ahora podemos acceder al frontend a través de la IP del nodo (que, en nuestro ambiente Kind, es accesible via localhost) y el puerto NodePort:"
          - "`curl localhost:$NODEPORT`"
          - "Debes ver la página HTML retornada por el frontend (Nginx). En un cluster real, podrías acceder a este servicio a través de la IP de cualquier nodo y el mismo puerto NodePort."
          - "Para demostrar la comunicación entre servicios, vamos a modificar el frontend para actuar como un proxy reverso para el backend. Vamos a crear un ConfigMap con una configuración Nginx que reenvía peticiones para '/api' al backend:"
          - "`kubectl create configmap nginx-config --from-literal=nginx.conf='events {} http { server { listen 80; location / { root /usr/share/nginx/html; } location /api { proxy_pass http://backend-service; } } }' -n servicios-lab`"
          - "Ahora, vamos a actualizar el Deployment del frontend para usar esta configuración:"
          - "`kubectl set volumes deployment/frontend-app --add --name=config --mount-path=/etc/nginx/nginx.conf --sub-path=nginx.conf --configmap-name=nginx-config -n servicios-lab`"
          - "Este comando agrega un volumen al Deployment 'frontend-app' que monta el ConfigMap 'nginx-config' en el path '/etc/nginx/nginx.conf'. Nginx leerá esta configuración y reenviará peticiones para '/api' al 'backend-service'."
          - "Vamos a esperar a que el Pod frontend sea recreado con la nueva configuración:"
          - "`kubectl rollout status deployment/frontend-app -n servicios-lab`"
          - "Ahora podemos probar el servicio. Cuando accedemos a '/api', el frontend debe reenviar la petición al backend:"
          - "`curl localhost:$NODEPORT/api`"
          - "Debes ver la respuesta del backend, demostrando que el frontend está reenviando peticiones al backend usando el servicio interno 'backend-service'."
        tips:
          - type: "warning"
            title: "Limitaciones del NodePort"
            content: "NodePort no es generalmente recomendado para producción pues: 1) Usa puertos no-estándar, 2) Expone puertos en todos los nodos, aunque no estén ejecutando el servicio, 3) Requiere gestión de IPs de nodos, que pueden cambiar."
          - type: "info"
            title: "Arquitectura Común"
            content: "Un patrón común en Kubernetes es tener servicios de frontend expuestos externamente con NodePort o LoadBalancer, mientras servicios de backend usan ClusterIP para comunicación interna."
          - type: "tip"
            title: "Encadenamiento de servicios"
            content: "Los servicios pueden comunicarse entre sí usando sus nombres DNS. Esto permite crear arquitecturas en capas donde cada componente se concentra en su función específica."
        validation:
          - command: "kubectl get service frontend-service -n servicios-lab -o jsonpath='{.spec.type}' 2>/dev/null || echo ''"
            expectedOutput: "NodePort"
            errorMessage: "El servicio 'frontend-service' del tipo NodePort no fue creado correctamente."
          - command: "NODEPORT=$(kubectl get service frontend-service -n servicios-lab -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null || echo ''); curl -s localhost:$NODEPORT/api | grep -i 'nginx' || echo 'fail'"
            expectedOutput: "nginx"
            errorMessage: "No fue posible acceder al backend a través del frontend. Verifica la configuración del proxy reverso."

      - name: "Limpieza de los Recursos"
        description: "Remueve todos los recursos creados durante el laboratorio, entendiendo cómo Kubernetes gestiona el ciclo de vida de los recursos."
        steps:
          - "Después de explorar los conceptos de servicios y Redes en Kubernetes, vamos a limpiar todos los recursos creados para mantener el cluster organizado."
          - "En Kubernetes, la eliminación de recursos puede hacerse de varias maneras. Podemos eliminar recursos individualmente o eliminar el namespace, que remueve todos los recursos dentro de él."
          - "Vamos a listar todos los recursos creados en este laboratorio:"
          - "`kubectl get all -n servicios-lab`"
          - "El comando `kubectl get all` muestra la mayoría de los recursos de Kubernetes, incluyendo Pods, servicios, Deployments, etc., pero no todos (por ejemplo, no muestra ConfigMaps)."
          - "Vamos a empezar eliminando los servicios:"
          - "`kubectl delete service frontend-service backend-service -n servicios-lab`"
          - "Este comando elimina los dos servicios que creamos. Observa que la eliminación de un servicio no afecta los Pods subyacentes - continúan en ejecución."
          - "Ahora, vamos a eliminar los Deployments:"
          - "`kubectl delete deployment frontend-app backend-app -n servicios-lab`"
          - "Cuando eliminamos un Deployment, Kubernetes elimina automáticamente todos los Pods gestionados por él. Esto demuestra el concepto de propiedad en Kubernetes - cuando un recurso 'padre' es eliminado, sus 'hijos' también son eliminados."
          - "Vamos a verificar si los Pods fueron removidos:"
          - "`kubectl get pods -n servicios-lab`"
          - "No debería haber más Pods listados."
          - "Ahora, vamos a eliminar el ConfigMap:"
          - "`kubectl delete configmap nginx-config -n servicios-lab`"
          - "Finalmente, vamos a eliminar el namespace, lo que removería todos los recursos restantes en él (caso hubiésemos olvidado alguno):"
          - "`kubectl delete namespace servicios-lab`"
          - "Esta es una forma eficiente de limpiar todos los recursos de un proyecto o experimento de una sola vez. Sin embargo, ten cuidado al usar este método en ambientes compartidos o de producción."
          - "Vamos a verificar si el namespace fue removido:"
          - "`kubectl get namespace servicios-lab || echo 'Namespace removido con éxito'`"
          - "Debes ver el mensaje 'Namespace removido con éxito', indicando que el namespace no existe más."
        tips:
          - type: "warning"
            title: "Eliminación de Namespaces"
            content: "La eliminación de un namespace es una operación destructiva que no puede ser deshecha. Todos los recursos en el namespace serán permanentemente removidos. Usa con precaución en ambientes compartidos o de producción."
          - type: "info"
            title: "Cascada de Eliminación"
            content: "Kubernetes usa el concepto de 'propiedad' para gestionar la eliminación en cascada. Cuando un recurso 'padre' (como un Deployment) es eliminado, todos los recursos 'hijos' (como los Pods) también son eliminados automáticamente."
          - type: "tip"
            title: "Verificación Antes de la Eliminación"
            content: "Antes de eliminar recursos, especialmente en producción, usa `kubectl get <recurso> -o yaml` o `kubectl describe <recurso>` para verificar si estás eliminando los recursos correctos."
