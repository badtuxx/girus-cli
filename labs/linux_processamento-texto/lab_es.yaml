apiVersion: v1
kind: ConfigMap
metadata:
  name: linux-processamento-texto-lab-es
  namespace: girus
  labels:
    app: girus-lab-template
data:
  lab.yaml: |
    name: linux-processamento-texto-es
    title: "Procesamiento de Texto en Linux: grep, sed, awk"
    description: "Domina las herramientas esenciales de manipulación de texto en Linux, aprendiendo a buscar patrones con grep, editar flujos de texto con sed y procesar datos estructurados con awk. Este laboratorio guiado proporciona una base sólida para automatización, análisis de logs y administración de sistemas Linux a través del procesamiento eficiente de texto."
    duration: 25m
    image: "linuxtips/girus-devops:0.1"
    tasks:
      - name: "Buscando Patrones con grep"
        description: "Aprende a utilizar grep para encontrar y filtrar texto por patrones, comprendiendo sus principales opciones y casos de uso para análisis de archivos y logs."
        steps:
          - "El **grep** (Global Regular Expression Print) es una de las herramientas más importantes para procesamiento de texto en Linux. Permite buscar patrones específicos en archivos o en la salida de otros comandos, siendo fundamentalmente útil para administración de sistemas y análisis de logs."
          - "El grep trabaja línea por línea, examinando cada una para determinar si contiene el patrón de búsqueda especificado, mostrando apenas las líneas que corresponden al criterio."
          - "Vamos a comenzar creando un archivo de ejemplo para demostrar las funcionalidades de grep:"
          - "`for i in \"Línea 1 con la palabra linux\" \"Línea 2 sin la palabra\" \"Línea 3 con linux nuevamente\" \"LÍNEA 4 CON LINUX\"; do echo $i >> archivo_ejemplo.txt; done`"
          - "Este comando crea un archivo llamado <code>archivo_ejemplo.txt</code> con 4 líneas diferentes. Usamos el operador de redirección <code>>></code> para enviar la salida del comando <code>echo</code> al archivo."
          - "**Búsqueda básica con grep:**"
          - "La forma más simple de usar grep es proporcionar un patrón de búsqueda y el nombre del archivo:"
          - "`grep 'linux' archivo_ejemplo.txt`"
          - "Este comando mostrará apenas las líneas que contienen la palabra 'linux'. Observa que, por defecto, grep es case-sensitive (sensible a mayúsculas/minúsculas), entonces 'linux' y 'LINUX' son tratados como patrones diferentes."
          - "**Ignorando case (mayúsculas/minúsculas):**"
          - "Para realizar una búsqueda que ignore diferencias entre mayúsculas y minúsculas, usamos la flag <code>-i</code> (insensitive):"
          - "`grep -i 'linux' archivo_ejemplo.txt`"
          - "Ahora grep mostrará todas las líneas que contienen 'linux', 'LINUX', 'Linux', o cualquier variación de capitalización."
          - "**Contando ocurrencias:**"
          - "En vez de mostrar las líneas correspondientes, podemos apenas contar cuántas de ellas existen con la flag <code>-c</code> (count):"
          - "`grep -c -i 'linux' archivo_ejemplo.txt`"
          - "Este comando retornará <code>3</code>, indicando que tres líneas contienen la palabra 'linux' (en cualquier capitalización)."
          - "**Búsquedas más avanzadas:**"
          - "El grep también permite búsquedas más complejas usando expresiones regulares. Por ejemplo, para encontrar líneas que comienzan con 'Línea':"
          - "`grep '^Línea' archivo_ejemplo.txt`"
          - "El carácter <code>^</code> es un metacarácter que representa el inicio de una línea."
          - "Para encontrar líneas que terminan con 'nuevamente':"
          - "`grep 'nuevamente$' archivo_ejemplo.txt`"
          - "El carácter <code>$</code> representa el fin de una línea."
          - "**Mostrando el contexto:**"
          - "A veces, es útil ver algunas líneas antes o después del resultado. Podemos usar las flags <code>-B</code> (before) y <code>-A</code> (after):"
          - "`grep -A 1 -B 1 'sin' archivo_ejemplo.txt`"
          - "Este comando mostrará la línea que contiene 'sin', más una línea antes y una después, proporcionando contexto al resultado."
        tips:
          - type: "info"
            title: "El poder de grep"
            content: "grep es extremadamente útil para buscar información en logs, archivos de configuración y salidas de otros comandos. Explora opciones como -r (recursivo), -v (invertir búsqueda), -n (número de línea)."
          - type: "tip"
            title: "Combinando grep con otros comandos"
            content: "grep es frecuentemente usado con pipes (|) para filtrar la salida de otros comandos. Por ejemplo: `ps aux | grep nginx` para encontrar procesos de Nginx en ejecución."
          - type: "warning"
            title: "Performance en archivos grandes"
            content: "Para búsquedas en archivos muy grandes, considera usar herramientas más específicas como `zgrep` para archivos comprimidos o `ack`/`ag` que están optimizadas para búsquedas rápidas."
        validation:
          - command: "grep -c -i 'linux' archivo_ejemplo.txt"
            expectedOutput: "3"
            errorMessage: "El comando grep -c -i no retornó el número esperado de líneas. Verifica si el archivo fue creado correctamente."

      - name: "Editando Flujos con sed"
        description: "Comprende cómo sed (Stream Editor) puede ser usado para transformar texto usando sustituciones, deleciones y otros tipos de manipulaciones en archivos o flujos de datos."
        steps:
          - "El **sed** (Stream Editor) es una poderosa herramienta de procesamiento de texto que permite transformar el contenido de un archivo o flujo de datos sin necesidad de abrir un editor interactivo. El sed trabaja como un editor no interactivo que procesa el texto línea por línea, aplicando las transformaciones especificadas."
          - "Vamos a continuar usando el archivo de ejemplo que creamos anteriormente para demostrar las capacidades de sed:"
          - "**Sustitución básica:**"
          - "La operación más común en sed es la sustitución de texto usando el comando <code>s</code> (substitute):"
          - "`sed 's/linux/GIRUS/' archivo_ejemplo.txt`"
          - "Este comando sustituye la primera ocurrencia de 'linux' por 'GIRUS' en cada línea del archivo. Por defecto, sed no altera el archivo original, apenas muestra el resultado de la transformación."
          - "Observa que apenas la primera ocurrencia en cada línea es sustituida. Si una línea tiene más de una ocurrencia de 'linux', apenas la primera será alterada."
          - "**Sustitución global e insensitiva a mayúsculas/minúsculas:**"
          - "Para sustituir todas las ocurrencias en cada línea, usamos la flag <code>g</code> (global). Para ignorar mayúsculas/minúsculas, usamos la flag <code>i</code> (insensitive):"
          - "`sed 's/linux/GIRUS/gi' archivo_ejemplo.txt`"
          - "Este comando sustituye todas las ocurrencias de 'linux' (independiente de la capitalización) por 'GIRUS' en todo el archivo."
          - "**Editando apenas líneas específicas:**"
          - "El sed también permite aplicar comandos apenas a líneas que corresponden a un patrón. Por ejemplo, vamos a eliminar todas las líneas que contienen la palabra 'sin':"
          - "`sed '/sin/d' archivo_ejemplo.txt`"
          - "Aquí, <code>/sin/</code> es un patrón de búsqueda y <code>d</code> es el comando de eliminación. Este comando remueve completamente todas las líneas que contienen 'sin'."
          - "**Modificando múltiples líneas:**"
          - "Podemos combinar varias operaciones usando múltiples comandos separados por punto y coma. Por ejemplo, vamos a sustituir 'linux' por 'GIRUS' y 'LÍNEA' por 'Registro':"
          - "`sed 's/linux/GIRUS/gi; s/LÍNEA/Registro/g' archivo_ejemplo.txt`"
          - "**Editando archivos en el lugar:**"
          - "Por defecto, sed no modifica el archivo original. Para guardar las alteraciones directamente en el archivo, usamos la flag <code>-i</code> (in-place):"
          - "`sed -i 's/linux/GIRUS/gi' archivo_ejemplo.txt`"
          - "Este comando modifica el archivo original directamente. En sistemas BSD como macOS, necesitas proporcionar una extensión de backup: <code>sed -i '' 's/linux/GIRUS/gi' archivo_ejemplo.txt</code>"
          - "**Aplicando condicionales:**"
          - "También podemos aplicar comandos apenas a líneas específicas por número. Por ejemplo, para sustituir 'linux' por 'GIRUS' apenas en la primera línea:"
          - "`sed '1 s/linux/GIRUS/' archivo_ejemplo.txt`"
          - "O para sustituir apenas en las líneas 1 a 3:"
          - "`sed '1,3 s/linux/GIRUS/g' archivo_ejemplo.txt`"
        tips:
          - type: "tip"
            title: "Sintaxis de sed"
            content: "La sintaxis básica para sustitución es 's/patrón/sustitución/flags'. Flags comunes: g (global, todas las ocurrencias), i (case-insensitive), p (print)."
          - type: "warning"
            title: "Backup antes de editar"
            content: "Al usar la opción -i para editar archivos en el lugar, es recomendable hacer un backup o especificar una extensión de backup (ej: `sed -i.bak`) para evitar pérdida accidental de datos."
          - type: "info"
            title: "Expresiones regulares"
            content: "El sed soporta expresiones regulares básicas por defecto. Para usar expresiones regulares extendidas (como `+`, `?`, etc.), usa la opción -E o -r dependiendo de tu distribución Linux."
        validation:
          - command: "sed 's/linux/GIRUS/gi' archivo_ejemplo.txt | grep -c 'GIRUS'"
            expectedOutput: "3"
            errorMessage: "La sustitución con sed no parece haber funcionado correctamente. Verifica la sintaxis del comando."

      - name: "Procesando Columnas con awk"
        description: "Explora el lenguaje de programación awk para procesar y analizar datos estructurados en columnas, aprendiendo a extraer, transformar y formatear información específica."
        steps:
          - "El **awk** es un lenguaje de programación completo, especializado en el procesamiento de datos basados en texto. Diferente de grep y sed, que funcionan principalmente con líneas enteras, awk es particularmente útil para procesar datos estructurados en columnas o campos."
          - "El nombre 'awk' viene de las iniciales de sus creadores: Alfred **A**ho, Peter **W**einberger y Brian **K**ernighan. Esta herramienta tiene capacidades avanzadas para manipulación de datos, incluyendo variables, funciones, y estructuras condicionales."
          - "Para demostrar el poder de awk, vamos a crear un archivo con datos estructurados en columnas:"
          - "`for i in \"col1 col2 col3\" \"val1 val2 val3\" \"xyz abc 123\"; do echo $i >> archivo_columnas.txt; done`"
          - "Este archivo simula datos tabulares, con tres columnas separadas por espacios."
          - "**Concepto fundamental: campos y registros**"
          - "En awk, cada línea del archivo es considerada un 'registro', y cada palabra (o conjunto de caracteres separados por delimitadores) es un 'campo'. Por defecto, los campos son separados por espacios en blanco (espacios o tabs)."
          - "- El registro completo es referenciado como <code>$0</code>"
          - "- Los campos individuales son referenciados como <code>$1</code>, <code>$2</code>, <code>$3</code>, etc."
          - "- <code>$NF</code> se refiere al último campo (NF = Number of Fields)"
          - "**Imprimiendo campos específicos:**"
          - "El comando más básico de awk es imprimir uno o más campos de cada línea:"
          - "`awk '{print $1}' archivo_columnas.txt`"
          - "Este comando imprime apenas el primer campo (columna) de cada línea."
          - "Para imprimir múltiples campos con formato personalizado:"
          - "`awk '{print \"Columna 1: \" $1, \"Columna 3: \" $3}' archivo_columnas.txt`"
          - "Observa que awk permite incluir texto literal entre comillas en la salida."
          - "**Imprimiendo el último campo:**"
          - "Para imprimir el último campo de cada línea, independientemente de cuántos campos tenga la línea:"
          - "`awk '{print $NF}' archivo_columnas.txt`"
          - "La variable especial <code>NF</code> contiene el número de campos de la línea actual, entonces <code>$NF</code> se refiere al último campo."
          - "**Aplicando condiciones:**"
          - "El awk permite procesar apenas líneas que atiendan a ciertas condiciones. Por ejemplo, para imprimir apenas líneas donde el tercer campo es 'val3':"
          - "`awk '$3 == \"val3\" {print $0}' archivo_columnas.txt`"
          - "Aquí, <code>$3 == \"val3\"</code> es una condición que debe ser satisfecha para que el bloque de código entre llaves sea ejecutado."
          - "**Usando separadores diferentes:**"
          - "Por defecto, awk considera espacios en blanco como separadores de campo. Podemos especificar un separador diferente con la opción <code>-F</code>. Vamos a crear un archivo CSV para demostrar:"
          - "`for i in \"Nombre,Edad,Ciudad\" \"Juan,35,São Paulo\" \"María,28,Rio de Janeiro\" \"Pedro,42,Belo Horizonte\"; do echo $i >> archivo_csv.txt; done`"
          - "Ahora podemos procesar este archivo especificando la coma como separador:"
          - "`awk -F, '{print \"Nombre: \" $1, \"Edad: \" $2}' archivo_csv.txt`"
          - "**Cálculos y variables:**"
          - "El awk soporta operaciones matemáticas y variables. Por ejemplo, para calcular el promedio de edad en nuestro archivo CSV:"
          - "`awk -F, 'NR>1 {sum+=$2; count++} END {print \"Promedio de edad: \" sum/count}' archivo_csv.txt`"
          - "Este comando más complejo:"
          - "1. Usa <code>NR>1</code> para saltar el encabezado (NR = Number of Record, el número de la línea actual)"
          - "2. Para cada línea procesada, agrega el valor del segundo campo (<code>$2</code>, la edad) a la variable <code>sum</code> e incrementa <code>count</code>"
          - "3. Cuando el procesamiento termina (bloque <code>END</code>), calcula e imprime el promedio (sum/count)"
        tips:
          - type: "info"
            title: "awk para datos tabulares"
            content: "awk es poderoso para procesar archivos CSV o cualquier dato delimitado por espacios/tabs. Trata cada línea como un registro y cada palabra como un campo ($1, $2, ... $NF)."
          - type: "tip"
            title: "Bloques especiales BEGIN y END"
            content: "El awk permite definir bloques de código para ser ejecutados antes de procesar cualquier línea (BEGIN) y después de procesar todas las líneas (END), útil para inicializar variables o imprimir resultados finales."
          - type: "warning"
            title: "Performance en grandes datasets"
            content: "Para procesamiento de grandes volúmenes de datos, considera herramientas más especializadas como pandas (Python) o utilizar GNU awk (gawk) que posee extensiones que pueden mejorar la performance."
        validation:
          - command: "awk '{print $1}' archivo_columnas.txt | head -n 1"
            expectedOutput: "col1"
            errorMessage: "El awk no parece estar imprimiendo la primera columna correctamente."
          - command: "awk -F, 'NR>1 {sum+=$2} END {print sum}' archivo_csv.txt"
            expectedOutput: "105"
            errorMessage: "La suma de las edades en el archivo CSV no está correcta. Verifica si el archivo fue creado adecuadamente."
