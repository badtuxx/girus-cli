apiVersion: v1
kind: ConfigMap
metadata:
  name: linux-gerenciamento-processos-lab-es
  namespace: girus
  labels:
    app: girus-lab-template
data:
  lab.yaml: |
    name: linux-gerenciamento-processos-es
    title: "Administración y Monitoreo de Procesos en Linux"
    description: "Aprende a monitorear, controlar y administrar procesos en el sistema Linux usando herramientas nativas como ps, top, kill y pgrep. Este laboratorio guiado explora conceptos fundamentales de procesos en sistemas operativos Linux, incluyendo jerarquía de procesos, estados, señales y técnicas para identificación de problemas de rendimiento."
    duration: 30m
    image: "linuxtips/girus-devops:0.1"
    tasks:
      - name: "Conceptos Fundamentales de Procesos Linux"
        description: "Comprende qué son los procesos en Linux, cómo están organizados y gestionados por el kernel."
        steps:
          - "**¿Qué son los Procesos en Linux?**"
          - "En Linux, un proceso es una instancia de un programa en ejecución. Cada proceso posee:"
          - "- Un identificador único llamado PID (Process ID)"
          - "- Un espacio de memoria aislado"
          - "- Recursos del sistema asignados por el kernel"
          - "- Un estado de ejecución (running, sleeping, stopped, zombie, etc.)"
          - "- Permisos basados en el usuario que lo ejecutó"
          - "**Jerarquía de Procesos**"
          - "Linux organiza los procesos en una estructura jerárquica padre-hijo:"
          - "- Todo proceso (excepto el proceso init/systemd, PID 1) tiene un proceso padre"
          - "- Los procesos pueden crear procesos hijos a través de la llamada del sistema <code>fork()</code>"
          - "- Si un proceso padre termina antes que sus hijos, estos se convierten en 'huérfanos' y son adoptados por el proceso init/systemd"
          - "- Si un proceso hijo termina, se convierte en un 'zombie' hasta que su padre llame <code>wait()</code> para obtener su estado de salida"
          - "**Estados de los Procesos**"
          - "Los procesos Linux pueden estar en diferentes estados:"
          - "- **Running (R)**: En ejecución o listo para ejecutar"
          - "- **Sleeping**: Esperando por un evento o recurso"
          - "  - **Interruptible (S)**: Puede ser despertado por señales"
          - "  - **Uninterruptible (D)**: No responde a señales (generalmente esperando por I/O)"
          - "- **Stopped (T)**: Proceso pausado, generalmente por una señal SIGSTOP"
          - "- **Zombie (Z)**: Proceso terminado, pero su padre no ha recolectado el estado de salida"
          - "**Señales**"
          - "Linux usa señales como un mecanismo de comunicación entre procesos:"
          - "- SIGHUP (1): Tradicionalmente usado para recargar configuraciones"
          - "- SIGINT (2): Interrupción (equivalente a presionar Ctrl+C)"
          - "- SIGKILL (9): Termina el proceso inmediatamente, no puede ser ignorado"
          - "- SIGTERM (15): Solicita término gracioso (por defecto del comando kill)"
          - "- SIGSTOP (19): Pausa el proceso, no puede ser ignorado"
          - "Vamos a explorar en la práctica cómo visualizar y administrar procesos."
        tips:
          - type: "info"
            title: "Prioridad de Procesos"
            content: "En Linux, cada proceso tiene un valor de 'nice' que determina su prioridad. Valores menores significan mayor prioridad. El rango va de -20 (más prioritario) a 19 (menos prioritario)."
          - type: "tip"
            title: "Diferencia entre Thread y Proceso"
            content: "En Linux, los threads son implementados como procesos (llamados LWP - Light Weight Process) que comparten recursos como espacio de memoria. El comando 'ps -eLf' lista threads como procesos individuales."
          - type: "warning"
            title: "Procesos Zombies"
            content: "Los procesos zombies consumen una pequeña cantidad de recursos del sistema. Sin embargo, un gran número de ellos puede indicar un problema en el programa padre, que no está gestionando correctamente sus hijos."
        validation:
          - command: "ps -p 1 -o comm= | grep -qE 'systemd|init' && echo 'ok'"
            expectedOutput: "ok"
            errorMessage: "No fue posible verificar el proceso init/systemd (PID 1). Verifica si el sistema está funcionando correctamente."

      - name: "Visualizando y Monitoreando Procesos"
        description: "Aprende a usar las herramientas ps y top para obtener información detallada sobre procesos en ejecución en el sistema."
        steps:
          - "**Comando ps: Listado Estático de Procesos**"
          - "El comando <code>ps</code> (process status) es una de las herramientas más fundamentales para visualizar procesos. Captura una instantánea de los procesos activos en el momento de la ejecución."
          - "**Lista básica de procesos:**"
          - "`ps`"
          - "Por defecto, ps muestra solo los procesos asociados a tu terminal actual."
          - "**Lista completa de todos los procesos:**"
          - "`ps aux`"
          - "Donde:"
          - "- <code>a</code>: Muestra procesos de todos los usuarios"
          - "- <code>u</code>: Formato orientado al usuario con más detalles"
          - "- <code>x</code>: Incluye procesos sin terminal de control"
          - "**Analizando la salida de ps aux:**"
          - "Cada columna proporciona información importante sobre los procesos:"
          - "- **USER**: Usuario que ejecutó el proceso"
          - "- **PID**: ID del proceso"
          - "- **%CPU**: Porcentaje de uso de CPU"
          - "- **%MEM**: Porcentaje de uso de memoria física"
          - "- **VSZ**: Tamaño virtual de memoria en KB"
          - "- **RSS**: Tamaño de memoria física residente en KB"
          - "- **TTY**: Terminal asociado al proceso"
          - "- **STAT**: Estado del proceso (R=running, S=sleeping, T=stopped, Z=zombie, etc.)"
          - "- **START**: Hora de inicio del proceso"
          - "- **TIME**: Tiempo acumulado de CPU"
          - "- **COMMAND**: Comando ejecutado"
          - "**Visualizando jerarquía de procesos:**"
          - "`ps auxf`"
          - "La opción <code>f</code> muestra los procesos en un árbol, facilitando la visualización de la jerarquía padre-hijo."
          - "**Filtrando procesos específicos:**"
          - "`ps aux | grep bash`"
          - "Este comando lista todos los procesos y filtra solo aquellos que contienen 'bash' en el nombre."
          - "**Visualizando información específica:**"
          - "`ps -eo pid,ppid,cmd,%cpu,%mem --sort=-%cpu`"
          - "Este comando personalizado muestra PID, PPID (ID del proceso padre), comando, uso de CPU y memoria, ordenados por uso de CPU."
          - "**Top: Monitoreo Dinámico en Tiempo Real**"
          - "Mientras que <code>ps</code> proporciona una instantánea estática, <code>top</code> ofrece una vista dinámica, actualizándose regularmente."
          - "`top`"
          - "La primera parte muestra estadísticas del sistema, incluyendo:"
          - "- Uptime y carga promedio"
          - "- Número total de procesos y sus estados"
          - "- Uso de CPU (us=usuario, sy=sistema, ni=nice, id=idle, wa=espera de I/O, etc.)"
          - "- Uso de memoria y swap"
          - "La segunda parte muestra la lista de procesos, que puede ser ordenada y filtrada interactivamente."
          - "**Comandos interactivos útiles en top:**"
          - "- <code>P</code>: Ordena por uso de CPU (por defecto)"
          - "- <code>M</code>: Ordena por uso de memoria"
          - "- <code>T</code>: Ordena por tiempo de ejecución"
          - "- <code>k</code>: Envía una señal a un proceso (permite matar procesos)"
          - "- <code>r</code>: Altera la prioridad nice de un proceso"
          - "- <code>c</code>: Alterna entre mostrar el comando completo o resumido"
          - "- <code>h</code> o <code>?</code>: Muestra ayuda"
          - "- <code>q</code>: Sale de top"
          - "**Versión no interactiva de top (útil para scripts):**"
          - "`top -bn1 | head -n 15`"
          - "Este comando ejecuta top en modo batch (<code>-b</code>) por solo una iteración (<code>-n1</code>) y muestra las primeras 15 líneas."
          - "**Alternativas a top:**"
          - "Linux ofrece alternativas más avanzadas para monitoreo:"
          - "- <code>htop</code>: Versión mejorada de top con interfaz colorida e interactiva"
          - "- <code>atop</code>: Registra actividad para análisis histórico"
          - "- <code>glances</code>: Herramienta integral con muchas métricas"
          - "Estos utilitarios pueden no estar disponibles en todas las distribuciones por defecto, pero son herramientas valiosas para monitoreo avanzado."
        tips:
          - type: "info"
            title: "Entendiendo la Carga Promedio"
            content: "Los tres números mostrados en la carga promedio (load average) representan el promedio de procesos en la cola de ejecución en los últimos 1, 5 y 15 minutos, respectivamente. Una carga mayor al número de CPUs generalmente indica un sistema sobrecargado."
          - type: "tip"
            title: "Filtros Avanzados en ps"
            content: "Usa opciones como '-C' para filtrar por nombre de comando ('ps -C nginx'), '-U' para filtrar por usuario ('ps -U root'), o '-t' para filtrar por terminal ('ps -t pts/0')."
          - type: "warning"
            title: "Interpretando Uso de Memoria"
            content: "Linux utiliza memoria no asignada para caché de disco. Por eso, un sistema puede parecer tener poca memoria libre, pero en realidad está usando memoria de forma eficiente para caché, que puede ser liberada cuando sea necesario."
        validation:
          - command: "ps aux | grep $$ | grep bash &> /dev/null && echo 'ok'"
            expectedOutput: "ok"
            errorMessage: "El comando 'ps aux' no parece estar listando el proceso del shell actual."
          - command: "top -bn1 | head -n 1 | grep -q 'top' && echo 'ok'"
            expectedOutput: "ok"
            errorMessage: "El comando 'top -bn1' no está funcionando como se esperaba."

      - name: "Encontrando y Filtrando Procesos Específicos"
        description: "Aprende a localizar procesos basándote en diferentes criterios usando pgrep, pidof y técnicas de filtrado."
        steps:
          - "**Herramientas para Encontrar Procesos**"
          - "Linux ofrece varias herramientas especializadas para encontrar procesos específicos:"
          - "**pgrep: Encontrando Procesos por Nombre y Atributos**"
          - "Vamos a iniciar algunos procesos para experimentación:"
          - "`sleep 300 &`"
          - "`sleep 600 &`"
          - "El comando <code>pgrep</code> está diseñado específicamente para encontrar PIDs basándose en criterios de búsqueda:"
          - "`pgrep sleep`"
          - "Este comando retorna los PIDs de todos los procesos <code>sleep</code> en ejecución."
          - "**Opciones útiles de pgrep:**"
          - "- <code>-f</code>: Coincide con el patrón en toda la línea de comando, no solo en el nombre del proceso"
          - "`pgrep -f 'sleep 3'`"
          - "- <code>-l</code>: Lista el nombre del proceso junto con el PID"
          - "`pgrep -l sleep`"
          - "- <code>-a</code>: Lista el comando completo junto con el PID"
          - "`pgrep -a sleep`"
          - "- <code>-u</code>: Filtra por usuario"
          - "`pgrep -u $(id -u) sleep`"
          - "- <code>-v</code>: Invierte la coincidencia (procesos que no coinciden)"
          - "`pgrep -v sleep`"
          - "- <code>-n</code>: Lista solo el proceso más reciente"
          - "`pgrep -n sleep`"
          - "- <code>-o</code>: Lista solo el proceso más antiguo"
          - "`pgrep -o sleep`"
          - "**pidof: Una Alternativa Directa**"
          - "El comando <code>pidof</code> es una alternativa más simple que retorna los PIDs de un programa específico:"
          - "`pidof sleep`"
          - "**Filtrado Avanzado con ps y grep**"
          - "Para búsquedas más complejas, podemos combinar <code>ps</code> con <code>grep</code>:"
          - "`ps aux | grep '[s]leep'`"
          - "El patrón <code>[s]leep</code> evita que el propio comando grep aparezca en los resultados."
          - "**Encontrando procesos por uso de recursos:**"
          - "`ps aux --sort=-%cpu | head -n 5`"
          - "Este comando lista los 5 procesos que más consumen CPU."
          - "`ps aux --sort=-%mem | head -n 5`"
          - "Este comando lista los 5 procesos que más consumen memoria."
          - "**Almacenando PIDs en variables para uso posterior:**"
          - "`SLEEP_PID=$(pgrep -f 'sleep 300' | head -n 1)`"
          - "`echo \"El PID del proceso 'sleep 300' es: $SLEEP_PID\"`"
          - "Esta técnica es especialmente útil en scripts para automatizar la administración de procesos."
        tips:
          - type: "tip"
            title: "pgrep vs ps | grep"
            content: "Usar 'pgrep' es generalmente más seguro y eficiente que 'ps aux | grep nombre_proceso', ya que evita encontrar el propio comando grep en la lista y fue específicamente diseñado para este fin."
          - type: "info"
            title: "Expresiones Regulares"
            content: "Tanto pgrep como grep aceptan expresiones regulares para filtrado más sofisticado. Por ejemplo, 'pgrep -f \"sleep (300|600)\"' encontraría procesos con sleep 300 o sleep 600."
          - type: "warning"
            title: "Proceso con Múltiples Instancias"
            content: "Cuando un proceso tiene varias instancias, como servidores web o bases de datos, verifica cuidadosamente cuál instancia específica quieres administrar, posiblemente usando el argumento completo del comando con 'pgrep -f'."
        validation:
          - command: "pgrep sleep &> /dev/null && echo 'found'"
            expectedOutput: "found"
            errorMessage: "No fue posible encontrar el proceso 'sleep' usando pgrep. Asegúrate de que esté en ejecución."

      - name: "Gerenciando Procesos con Señales"
        description: "Aprende a controlar compuertomentos de procesos enviando diferentes señales a través de comandos como kill, killall5 y pkill."
        steps:
          - "**Entendiendo Señales y su Importancia**"
          - "Señales son una forma de comunicación inter-proceso (IPC) en Linux para controlar el compuertomento de los procesos. Se usan para notificar un proceso sobre eventos específicos, como:"
          - "- Solicitudes para terminar su ejecución"
          - "- Indicaciones para pausar o retomar operaciones"
          - "- Pedidos para recargar su configuración"
          - "**Listando Señales Disponíbles**"
          - "Para ver todas las señales disponibles en el sistema:"
          - "`kill -l`"
          - "Las señales más comunes incluyen:"
          - "- **SIGHUP (1)**: Hang up, tradicionalmente usado para recargar configuraciones"
          - "- **SIGINT (2)**: Interrupt, enviado cuando presionas Ctrl+C"
          - "- **SIGQUIT (3)**: Quit, enviado cuando presionas Ctrl+\""
          - "- **SIGKILL (9)**: Kill, fuerza el término inmediatamente (no puede ser capturado o ignorado)"
          - "- **SIGTERM (15)**: Terminate, solicita término gracioso (por defecto del comando kill)"
          - "- **SIGSTOP (19)**: Stop, pausa la ejecución (no puede ser capturado)"
          - "- **SIGCONT (18)**: Continue, retoma la ejecución después de un SIGSTOP"
          - "**Usando el comando kill**"
          - "El comando <code>kill</code> envia señales a procesos específicos por PID:"
          - "Primero, vamos verificar y capturar un PID de un proceso 'sleep':"
          - "`PID_SLEEP=$(pgrep sleep | head -n 1)`"
          - "`echo \"Enviando señal al proceso sleep (PID: $PID_SLEEP)\"`"
          - "Enviar señal de terminación predeterminada (SIGTERM):"
          - "`kill $PID_SLEEP`"
          - "El proceso sleep debe terminar de forma limpia. Verifica si se ha cerrado:"
          - "`sleep 1; pgrep -f \"^sleep\" | grep -q $PID_SLEEP || echo 'Proceso terminado'`"
          - "**utilizando otras señales con kill**"
          - "Vamos a iniciar otro proceso sleep:"
          - "`sleep 300 &`"
          - "`PID_SLEEP=$(pgrep sleep | head -n 1)`"
          - "Enviar SIGSTOP para pausar la ejecución:"
          - "`kill -STOP $PID_SLEEP`"
          - "Verificar estado del proceso (T = stopped):"
          - "`ps -p $PID_SLEEP -o pid,state,cmd`"
          - "Enviar SIGCONT para retomar la ejecución:"
          - "`kill -CONT $PID_SLEEP`"
          - "Verificar estado del proceso nuevamente (deberá cambiar a S o R):"
          - "`ps -p $PID_SLEEP -o pid,state,cmd`"
          - "Usar SIGKILL cuando un proceso no responde:"
          - "`kill -9 $PID_SLEEP`"
          - "Verificar si el proceso se ha cerrado:"
          - "`sleep 0.5; ps -p $PID_SLEEP &>/dev/null || echo 'Proceso eliminado con SIGKILL'`"
          - "**comandos killall y pkill**"
          - "El comando <code>killall</code> envia señales a procesos basándose en sus nombres."
          - "El comando <code>killall</code> no viene instalado por defecto en ambientes SystemV (que es el entorno utilizado en nuestro laboratorio). Usa el comando siguiente para instalárselo:"
          - "`sudo apt update && sudo apt install -y psmisc`"
          - "Inicia varios procesos sleep:"
          - "`sleep 200 & sleep 250 & sleep 300 &`"
          - "Cierra todos los procesos sleep de una vez:"
          - "`killall sleep`"   
          - "Verifica si se han cerrado:"
          - "`pgrep sleep || echo 'Todos los procesos sleep se han cerrado'`"
          - "El comando <code>pkill</code> es más flexible, combinando recursos del pgrep y del kill:"
          - "Inicia algunos procesos:"
          - "`sleep 100 & sleep 200 & sleep 300 &`"
          - "Cierra solo los procesos con un patrón específico:"
          - "`pkill -f 'sleep 2'`"
          - "Esto cerrará los procesos sleep con argumento '200' o '300', pero no '100'."
          - "Verifica cuáles procesos quedan:"
          - "`pgrep -fa sleep`"
          - "Cierra todos los restantes:"
          - "`pkill sleep`"
        tips:
          - type: "warning"
            title: "Uso del SIGKILL (kill -9)"
            content: "SIGKILL fuerza la terminación inmediata de un proceso sin permitir que limpie recursos o guarde datos. Usa solo como último recurso cuando SIGTERM falla, ya que puede causar inconsistencias de datos o recursos huérfanos."
          - type: "info"
            title: "Procesos 'Unkillable'"
            content: "Procesos en estado D (uninterruptible sleep) no pueden ser interrumpidos incluso con SIGKILL. Estos procesos generalmente están esperando operaciones de I/O y solo terminarán cuando se complete esa operación o el sistema se reinicie."
          - type: "tip"
            title: "Gerenciando Grupos de Procesos"
            content: "Para matar un proceso y todos sus hijos, usa la señal negativa con kill: 'kill -TERM -$PID' envia la señal a todo el grupo de procesos asociado al PID especificado."
          - type: "info"
            title: "comando 'killall' en SystemV"
            content: "El comando `killall` no viene instalado por defecto en ambientes SystemV (que es el entorno utilizado en nuestro laboratorio)."
        validation:
          - command: "pgrep sleep || echo 'killed'"
            expectedOutput: "killed"
            errorMessage: "Algún proceso 'sleep' aún está en ejecución después de los comandos de terminación."
          - command: "kill -l | grep -q SIGKILL && echo 'ok'"
            expectedOutput: "ok"
            errorMessage: "El comando 'kill -l' no muestra la lista completa de señales disponibles."
